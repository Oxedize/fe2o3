File: lib.rs
#![forbid(unsafe_code)]
pub mod constant;
pub mod cfg;
pub mod core;
pub mod guard;
pub mod msg;
pub mod packet;
pub mod pow;
pub mod schemes;
pub mod server;
pub use crate::core::Shield;
File: guard/user.rs
use fe2o3_core::{
    prelude::*,
    map::MapMut,
};
use fe2o3_hash::map::ShardMap;
use fe2o3_iop_hash::api::{
    Hasher,
    HashForm,
};
use fe2o3_jdat::id::NumIdDat;
use fe2o3_net::id::Uid;
use std::{
    clone::Clone,
    fmt::Debug,
    sync::RwLock,
};
#[derive(Clone, Debug)]
pub enum UserState {
    Unknown,
    Blacklist,
    Whitelist,
}
impl Default for UserState {
    fn default() -> Self {
        Self::Unknown
    }
}
#[derive(Clone, Debug, Default)]
pub struct UserLog<
    D: Clone + Debug + Default,
> {
    pub state:  UserState,
    pub data:   D,
}
#[derive(Debug)]
pub struct UserGuard<
    const C: usize,
    M: MapMut<HashForm, UserLog<D>> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
    D: Clone + Debug + Default,
> {
    pub umap: ShardMap<C, UserLog<D>, M, H, S>,
}
impl<
    const C: usize,
    M: MapMut<HashForm, UserLog<D>> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
    D: Clone + Debug + Default,
>
    UserGuard<C, M, H, S, D>
{
    pub fn drop_packet<
        const UIDL: usize,
        UID: NumIdDat<UIDL>,
    >(
        &self,
        uid:            &Uid<UIDL, UID>,
        accept_unknown: bool,
    )
        -> Outcome<bool>
    {
        let (key, locked_map) = res!(self.get_locked_map(&uid));
        let mut unlocked_map = lock_write!(locked_map);
        match unlocked_map.get_mut(&key) {
            Some(_ulog) => {
            },
            None => {
                if accept_unknown { 
                    let ulog = UserLog::default();
                    unlocked_map.insert(key, ulog);
                } else {
                    return Ok(true);
                }
            },
        }
        Ok(false)
    }
    pub fn get_locked_map<
        const UIDL: usize,
        UID: NumIdDat<UIDL>,
    >(
        &self,
        uid: &Uid<UIDL, UID>,
    )
        -> Outcome<(HashForm, &RwLock<M>)>
    {
        let key = res!(self.umap.key(&res!(uid.to_byte_array())));
        let locked_map = res!(self.umap.get_map_using_hash(&key));
        Ok((key, locked_map))
    }
}
File: guard/data.rs
use fe2o3_core::{
    prelude::*,
};
use fe2o3_crypto::{
    keys::{
        PublicKey,
        SecretKey,
    },
    scheme::SchemeTimestamp,
};
use fe2o3_hash::pow::ZeroBits;
use fe2o3_jdat::id::NumIdDat;
use fe2o3_net::id::Sid;
use std::{
    collections::{
        BTreeMap,
        BTreeSet,
    },
    net::{
        IpAddr,
        SocketAddr,
    },
    str::FromStr,
    sync::Arc,
};
pub struct Address;
impl Address {
    pub fn server_address<S: Into<String> + std::fmt::Display>(addr: S, port: u16) -> String {
        fmt!("{}:{}", addr, port)
    }
    pub fn socket_address_udp<
        S: Into<String> + std::fmt::Display,
    >(
        addr: S,
        port: u16,
    )
        -> Outcome<SocketAddr>
    {
        let sock_addr = SocketAddr::new(res!(IpAddr::from_str(&addr.into())), port);
        Ok(sock_addr)
    }
}
#[derive(Clone, Debug, Default)]
pub struct AddressData {
    pub my_zbits:   ZeroBits,
    pub your_zbits: ZeroBits,
}
impl AsMut<AddressData> for AddressData {
    fn as_mut(&mut self) -> &mut AddressData {
        self
    }
}
#[derive(Clone, Debug, Default)]
pub struct UserData<
    const SIDL: usize,
    const C: usize,
    SID: NumIdDat<SIDL>,
> {
    pub sigtpk_opt:         Option<PublicKey>,
    pub sigtpk_opt_old:     Option<PublicKey>,
    pub waiting_for_sigpk:  bool,
    pub sessions:           BTreeMap<Sid<SIDL, SID>, SecretKey>,
    pub code:               Option<[u8; C]>,
    pub pack_sigpk_set:     BTreeSet<PublicKey>,
    pub pack_sigpk_map:     BTreeMap<SchemeTimestamp, Vec<u8>>,
    pub sign_pack_this:     Option<Vec<u8>>,
}
File: guard/mod.rs
pub mod addr;
pub mod data;
pub mod user;
File: guard/addr.rs
use crate::{
    msg::external::{
        HandshakeType,
        MsgType,
    },
};
use fe2o3_core::{
    prelude::*,
    map::MapMut,
};
use fe2o3_data::ring::RingTimer;
use fe2o3_hash::map::ShardMap;
use fe2o3_iop_hash::api::{
    Hasher,
    HashForm,
};
use std::{
    clone::Clone,
    fmt::Debug,
    net::{
        IpAddr,
        SocketAddr,
    },
    sync::RwLock,
    time::{
        Duration,
        SystemTime,
    },
};
use rand::{
    self,
    Rng,
};
#[derive(Clone, Debug)]
pub enum AddressState<
    const N: usize,
    const R: u64,
> {
    Monitor(RingTimer<N>, u64),
    Throttle{
        reqs:       RingTimer<N>,
        tint_min:   Duration,
        start:      SystemTime,
        sunset:     Duration,
    },
    Blacklist,
    Whitelist,
}
impl<
    const N: usize,
    const R: u64,
> Default for AddressState<N, R> {
    fn default() -> Self {
        Self::Monitor(
            RingTimer::default(),
            R,
        )
    }
}
impl<
    const N: usize,
    const R: u64,
>
    AddressState<N, R>
{
    pub fn new_monitor(avg_rps_lim: u64) -> Self {
        Self::Monitor(
            RingTimer::default(),
            avg_rps_lim,
        )
    }
    pub fn new_throttle(tint_min: Duration, sunset: Duration) -> Self {
        Self::Throttle{
            reqs:   RingTimer::default(),
            tint_min,
            start:  SystemTime::now(),
            sunset,
        }
    }
}
#[derive(Clone, Debug, Default)]
pub struct AddressLog<
    const N: usize,
    const R: u64,
    D: Clone + Debug + Default,
> {
    pub state:          AddressState<N, R>,
    pub throttle_cnt:   u16,
    pub pending:        Option<(HandshakeType, SystemTime)>,
    pub data:           D,
}
#[derive(Debug)]
pub struct AddressGuard<
    const C: usize,
    M: MapMut<HashForm, AddressLog<N, R, D>> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
    const N: usize,
    const R: u64,
    D: Clone + Debug + Default,
> {
    pub amap:       ShardMap<C, AddressLog<N, R, D>, M, H, S>,
    pub arps_max:   u64,
    pub tint_min:   Duration,
    pub tsunset:    (u64, u64),
    pub blist_cnt:  u16,
    pub hreq_exp:   Duration,
}
impl<
    const C: usize,
    M: MapMut<HashForm, AddressLog<N, R, D>> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
    const N: usize,
    const R: u64,
    D: Clone + Debug + Default,
>
    AddressGuard<C, M, H, S, N, R, D>
{
    fn ip_addr_to_bytes(addr: &IpAddr) -> Vec<u8> {
        match addr {
            IpAddr::V4(addr) => addr.octets().to_vec(),
            IpAddr::V6(addr) => addr.octets().to_vec(),
        }
    }
    pub fn drop_packet(
        &self,
        msg_typ:    MsgType,
        src_addr:   &SocketAddr,
    )
        -> Outcome<bool>
    {
        let htyp = HandshakeType::from(msg_typ);
        if htyp == HandshakeType::Unknown {
            return Ok(false);
        }
        let (key, locked_map) = res!(self.get_locked_map(&src_addr));
        let mut new = false;
        {
            let mut unlocked_map = lock_write!(locked_map);
            match unlocked_map.get_mut(&key) {
                Some(alog) => {
                    match alog.state {
                        AddressState::Monitor(mut reqs, _avg_rps_lim) => {
                            reqs.update();
                            if reqs.avg_rps() > self.arps_max {
                                if alog.throttle_cnt >= self.blist_cnt {
                                    alog.state = AddressState::Blacklist;
                                    alog.throttle_cnt = alog.throttle_cnt + 1;
                                    return Ok(true);
                                } else {
                                    alog.state = AddressState::new_throttle(
                                        self.tint_min,
                                        Duration::from_secs(rand::thread_rng().gen_range(
                                            self.tsunset.0..self.tsunset.1
                                        )),
                                    );
                                    alog.throttle_cnt = alog.throttle_cnt + 1;
                                }
                            }
                        },
                        AddressState::Throttle{
                            mut reqs, ..
                        } => {
                            reqs.update();
                            if reqs.last_duration() < self.tint_min {
                                return Ok(true);
                            }
                        },
                        AddressState::Blacklist => return Ok(true),
                        AddressState::Whitelist => (),
                    }
                    match alog.pending {
                        Some((typ, when)) => {
                            match when.elapsed() {
                                Ok(wait) => if wait > self.hreq_exp {
                                    alog.pending = None;
                                } else {
                                    match typ {
                                        HandshakeType::Req1 => {
                                            if !htyp.is_hreq2() {
                                                return Ok(true);
                                            } else {
                                                alog.pending = Some((
                                                    htyp,
                                                    SystemTime::now(),
                                                ));
                                            }
                                        },
                                        HandshakeType::Req2 => {
                                            if htyp != HandshakeType::Req3 {
                                                return Ok(true);
                                            } else {
                                                alog.pending = None;
                                            }
                                        },
                                        _ => (),
                                    }
                                }
                                Err(_) => (),
                            }
                        },
                        None => {
                            match htyp {
                                HandshakeType::Req1 => alog.pending = Some((
                                    HandshakeType::Req1,
                                    SystemTime::now(),
                                )),
                                HandshakeType::Req2 |
                                HandshakeType::Req3 => return Ok(true),
                                _ => (),
                            }
                        },
                    }
                },
                None => new = true,
            }
        }
        if new {
            if htyp != HandshakeType::Req1 {
                return Ok(true);
            }
            let alog = AddressLog {
                pending: Some((
                    HandshakeType::Req1,
                    SystemTime::now(),
                )),
                ..Default::default()
            };
            res!(self.amap.insert_using_hash(key, alog));
        }
        Ok(false)
    }
    pub fn get_locked_map(
        &self,
        addr: &SocketAddr,
    )
        -> Outcome<(HashForm, &RwLock<M>)>
    {
        let ip_addr = addr.ip();
        let key = res!(self.amap.key(&Self::ip_addr_to_bytes(&ip_addr)));
        let locked_map = res!(self.amap.get_map_using_hash(&key));
        Ok((key, locked_map))
    }
}
File: msg/internal.rs
use std::{
    fmt::Debug,
};
#[derive(Clone, Debug)]
pub enum ServerMsg {
    Finish,
    Ready,
}
impl fe2o3_bot::msg::BotMsg<fe2o3_core::error::ErrTag> for ServerMsg {}
impl fe2o3_core::bot::CtrlMsg for ServerMsg {
    fn finish() -> Self { Self::Finish }
    fn ready() -> Self { Self::Ready }
}
File: msg/syntax.rs
use crate::{
    cfg::ShieldConfig,
    constant,
    msg::external::{
        HandshakeType,
        IdentifiedMessage,
        Message,
        MsgBuilder,
        MsgType,
    },
    guard::data::AddressData,
};
use fe2o3_core::{
    prelude::*,
    byte::{
        Encoding,
        IntoBytes,
    },
};
use fe2o3_iop_crypto::sign::Signer;
use fe2o3_jdat::{
    prelude::*,
    try_extract_dat_as,
    id::NumIdDat,
};
use fe2o3_hash::{
    pow::{
        Pristine,
        ZeroBits,
    },
};
use fe2o3_iop_hash::api::Hasher;
use fe2o3_net::id::{
    Mid,
    Sid,
    Uid,
};
use fe2o3_syntax::{
    msg::{
        Msg as SyntaxMsg,
        MsgCmd as SyntaxMsgCmd,
    },
    arg::{
        Arg,
        ArgConfig,
    },
    cmd::{
        Cmd,
        CmdConfig,
    },
    core::{
        Syntax,
        SyntaxRef,
        SyntaxConfig,
    },
};
use fe2o3_text::string::Stringer;
use std::{
    net::{
        SocketAddr,
        UdpSocket,
    },
    sync::Arc,
};
pub fn empty() -> Syntax {
    Syntax::from(SyntaxConfig {
        name:   fmt!("Shield Protocol"),
        ver:    Some(constant::VERSION.to_string()),
        about:  Some(fmt!("Signature and Hash In Every Little Datagram (SHIELD)")),
        ..Default::default()
    })
}
pub fn build() -> Outcome<Syntax>
{
    let mut p = empty();
    let arg_sid = Arg::from(ArgConfig {
        name:   fmt!("Sid"),
        hyph1:  fmt!("s"),
        hyph2:  Some(fmt!("sid")),
        evals:  vec![constant::SESSION_ID_KIND],
        help:   Some(fmt!("Session identifier (unsigned int)")),
        ..Default::default()
    });
    let arg_pow_zbits = Arg::from(ArgConfig {
        name:   fmt!("PowZeroBits"),
        hyph1:  fmt!("zb"),
        hyph2:  Some(fmt!("zero-bits")),
        evals:  vec![Kind::U16],
        help:   Some(fmt!("Use this number of zero bits for packet proof of work")),
        ..Default::default()
    });
    let arg_your_pack_sign_pk = Arg::from(ArgConfig {
        name:   fmt!("YourPacketPublicSigningKey"),
        hyph1:  fmt!("yppsk"),
        hyph2:  Some(fmt!("your-pack-sign-pk")),
        evals:  vec![Kind::BC64],
        help:   Some(fmt!("Your packet public signing key")),
        ..Default::default()
    });
    p = res!(p.add_arg(arg_sid.clone().required(false)));
    p = res!(p.add_arg(arg_pow_zbits.clone().required(true)));
    let mut c = Cmd::from(CmdConfig {
        name:   fmt!("hreq1"),
        help:   Some(fmt!("Initial handshake request")),
        ..Default::default()
    });
    c = res!(c.add_arg(arg_your_pack_sign_pk.clone()));
    p = res!(p.add_cmd(c));
    let mut c = Cmd::from(CmdConfig {
        name:   fmt!("hresp1"),
        help:   Some(fmt!("Initial handshake response")),
        ..Default::default()
    });
    c = res!(c.add_arg(arg_pow_zbits.clone().required(true)));
    c = res!(c.add_arg(arg_your_pack_sign_pk));
    p = res!(p.add_cmd(c));
    let c = Cmd::from(CmdConfig {
        name:   fmt!("hreq2"),
        help:   Some(fmt!("Second handshake request")),
        ..Default::default()
    });
    p = res!(p.add_cmd(c));
    let mut c = Cmd::from(CmdConfig {
        name:   fmt!("hresp2"),
        help:   Some(fmt!("Second handshake response")),
        ..Default::default()
    });
    let arg_skey_enc = Arg::from(ArgConfig {
        name:   fmt!("EncSymKey"),
        hyph1:  fmt!("sk"),
        hyph2:  Some(fmt!("sym-key")),
        evals:  vec![Kind::BC64],
        help:   Some(fmt!("Encrypted symmetric encryption key for session")),
        ..Default::default()
    });
    c = res!(c.add_arg(arg_skey_enc.required(true)));
    p = res!(p.add_cmd(c));
    Ok(p)
}
#[derive(Clone, Debug, Default)]
pub struct MsgFmt {
    pub syntax:     SyntaxRef,
    pub encoding:   Encoding,
}
#[derive(Clone, Debug, Default)]
pub struct MsgPow {
    pub zbits:  ZeroBits,
}
impl MsgPow {
    pub fn from_msg(msg: &mut SyntaxMsg) -> Outcome<Self> {
        let zbits = match msg.get_arg_vals_mut("-zb") {
            Some(v) => try_extract_dat_as!(v[0].extract(), ZeroBits, U8, U16, U32),
            None => return Err(err!(errmsg!(
                "No proof of work zero bits specified in message arguments (-zb).",
            ), Input, Missing)),
        };
        Ok(Self {
            zbits,
        })
    }
}
#[derive(Clone, Debug, Default)]
pub struct MsgIds<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
> {
    pub sid_opt:    Option<Sid<SIDL, SID>>,
    pub uid:        Uid<UIDL, UID>,
}
impl<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
>
    MsgIds<SIDL, UIDL, SID, UID>
{
    pub fn from_msg(uid: Uid<UIDL, UID>, msg: &mut SyntaxMsg) -> Outcome<Self> {
        let sid_opt = match msg.get_arg_vals_mut("-s") {
            Some(v) => Some(res!(Sid::<SIDL, SID>::from_dat(v[0].extract()))),
            None => None,
        };
        Ok(Self {
            uid,
            sid_opt,
        })
    }
}
pub trait ServerCommand<
    const SIDL: usize,
    const UIDL: usize,
    SID: NumIdDat<SIDL>,
    UID: NumIdDat<UIDL>,
>:
    Default + IdentifiedMessage + IntoBytes
{
    fn fmt(&self)       -> &MsgFmt;
    fn pow(&self)       -> &MsgPow;
    fn mid(&self)       -> &MsgIds<SIDL, UIDL, SID, UID>;
    fn syntax(&self)    -> &SyntaxRef           { &self.fmt().syntax }
    fn encoding(&self)  -> &Encoding            { &self.fmt().encoding }
    fn uid(&self)       -> Uid<UIDL, UID>    { self.mid().uid.clone() }
    fn sid_opt(&self)   -> Option<Sid<SIDL, SID>> {
        self.mid().sid_opt.as_ref().clone().copied()
    }
    fn pow_zbits(&self) -> ZeroBits { self.pow().zbits }
    fn pad_last(&self)  -> bool     { true }
    fn inc_sigpk(&self) -> bool;
    fn deconstruct(&mut self, _mcmd: &mut SyntaxMsgCmd) -> Outcome<()> { Ok(()) }
    fn construct(self)  -> Outcome<SyntaxMsg>;
    fn build<
        const MIDL: usize,
        MID: NumIdDat<MIDL>,
        H: Hasher + Send + 'static,
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
        S: Signer,
    >(
        self,
        builder: &MsgBuilder<H, P0, P1, PRIS, S>,
    )
        -> Outcome<Vec<Vec<u8>>>
    {
        let msg_name = self.name();
        let msg_typ = self.typ();
        let inc_sigpk = self.inc_sigpk();
        let pad_last = self.pad_last();
        let uid = self.uid().clone();
        let msg_byts = res!(self.into_bytes(Vec::new()));
        let (packets, warning) = res!(Message::create::<
            MIDL,
            UIDL,
            MID,
            UID,
            H,
            {constant::POW_INPUT_LEN},
            P0,
            P1,
            PRIS,
            S,
        >(
            msg_name,
            msg_byts,
            msg_typ,
            &constant::VERSION,
            uid,
            &ShieldConfig::chunker(builder.chunk_cfg.clone().set_pad_last(pad_last)),
            &builder.validator,
            &builder.powparams,
            inc_sigpk,
        ));
        if let Some(warning) = warning {
            warn!("{}", warning);
        }
        Ok(packets)
    }
    fn send_udp(
        src_sock:   &UdpSocket,
        trg_addr:   &SocketAddr,
        packets:    Vec<Vec<u8>>,
    )
        -> Outcome<()>
    {
        for packet in packets {
            res!(src_sock.send_to(&packet, &trg_addr));
        }
        Ok(())
    }
}
#[macro_export]
macro_rules! impl_into_bytes_for_server_msg {
    ($t:ty) => {
        impl IntoBytes for $t {
            fn into_bytes(self, buf: Vec<u8>) -> Outcome<Vec<u8>> {
                res!(self.construct()).into_bytes(buf)
            }
        }
    }
}
#[derive(Clone, Debug, Default)]
pub struct HReq1<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
> {
    pub fmt: MsgFmt,
    pub pow: MsgPow,
    pub mid: MsgIds<SIDL, UIDL, SID, UID>,
    pub peer_sigpk: Option<Vec<u8>>,
}
impl<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
>
    IntoBytes for HReq1<SIDL, UIDL, SID, UID>
{
    fn into_bytes(self, buf: Vec<u8>) -> Outcome<Vec<u8>> {
        res!(self.construct()).into_bytes(buf)
    }
}
impl<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
>
    IdentifiedMessage for HReq1<SIDL, UIDL, SID, UID>
{
    fn typ(&self) -> MsgType { HandshakeType::Req1 as MsgType }
    fn name(&self) -> &'static str { "hreq1" }
}
impl<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
>
    ServerCommand<SIDL, UIDL, SID, UID> for HReq1<SIDL, UIDL, SID, UID>
{
    fn fmt(&self) -> &MsgFmt { &self.fmt }
    fn pow(&self) -> &MsgPow { &self.pow }
    fn mid(&self) -> &MsgIds<SIDL, UIDL, SID, UID> { &self.mid }
    fn inc_sigpk(&self) -> bool { true }
    fn pad_last(&self) -> bool { false }
    fn construct(self) -> Outcome<SyntaxMsg> {
        let mut msg = SyntaxMsg::new(self.syntax().clone());
        msg.set_encoding(*self.encoding());
        if let Some(sid) = self.sid_opt() {
            msg = res!(msg.add_arg_val("-s", Some(res!(sid.to_dat()))));
        }
        msg = res!(msg.add_arg_val("-zb", Some(dat!(self.pow_zbits()))));
        let mut mcmd = res!(msg.new_cmd(self.name()));
        if let Some(sigpk) = &self.peer_sigpk {
            mcmd = res!(mcmd.add_arg_val("-yppsk", Some(dat!(sigpk.clone()))));
        }
        msg = res!(msg.add_cmd(mcmd));
        for line in Stringer::new(fmt!("{:?}", msg)).to_lines("  ") {
            debug!("{}", line);
        }
        res!(msg.validate());
        Ok(msg)
    }
    fn deconstruct(
        &mut self,
        mcmd: &mut SyntaxMsgCmd,
    )
        -> Outcome<()>
    {
        self.peer_sigpk = match mcmd.get_arg_vals_mut("-yppsk") {
            Some(vals) => Some(try_extract_dat!(vals[0].extract(), BC64)),
            None => None,
        };
        Ok(())
    }
}
impl<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
>
    HReq1<SIDL, UIDL, SID, UID>
{
    pub fn send<
        const MIDL: usize,
        MID: NumIdDat<MIDL>,
        H: Hasher + Send + 'static,
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
        S: Signer,
    >(
        syntax:     SyntaxRef,
        builder:    &MsgBuilder<H, P0, P1, PRIS, S>,
        _mid_opt:   Option<Mid<MIDL, MID>>,
        sid_opt:    Option<Sid<SIDL, SID>>,
        uid:        Uid<UIDL, UID>,
    )
        -> Outcome<()>
    {
        let msg = Self { 
            fmt: MsgFmt {
                syntax,
                encoding: constant::DEFAULT_MSG_ENCODING,
            },                                            
            mid: MsgIds {
                sid_opt,
                uid,
            },
            pow: MsgPow {
                zbits: builder.powparams.pvars.zbits,
            },
            ..Default::default()
        };
        let packets = res!(msg.build::<MIDL, MID, H, P0, P1, PRIS, S>(builder));
        <HReq1<SIDL, UIDL, SID, UID> as ServerCommand<SIDL, UIDL, SID, UID>>::send_udp(
            &builder.src_sock,
            &builder.trg_addr,
            packets,
        )
    }
    pub fn server_process(
        &mut self,
        mcmd:       &mut SyntaxMsgCmd,
        adata:      &mut AddressData,
    )
        -> Outcome<()>
    {
        res!(self.deconstruct(mcmd));
        adata.your_zbits = self.pow.zbits;
        debug!("Yay it worked!");
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct HResp1<
    const SIDL: usize,
    const UIDL: usize,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
> {
    pub fmt:        MsgFmt,
    pub pow:        MsgPow,
    pub mid:        MsgIds<SIDL, UIDL, SID, UID>,
    pub send_key:   bool,
}
File: msg/mod.rs
pub mod external;
pub mod internal;
pub mod syntax;
File: msg/external.rs
use crate::{
    packet::{
        PacketChunkState,
        PacketCount,
        PacketMeta,
        PacketValidator,
    },
};
use fe2o3_core::{
    prelude::*,
    byte::{
        ToBytes,
        ToByteArray,
    },
    map::MapMut,
    rand::RanDef,
};
use fe2o3_iop_crypto::sign::Signer;
use fe2o3_jdat::{
    chunk::{
        Chunker,
        ChunkConfig,
    },
    id::NumIdDat,
    version::SemVer,
};
use fe2o3_hash::{
    map::ShardMap,
    pow::{
        PowCreateParams,
        Pristine,
    },
};
use fe2o3_iop_hash::api::{
    Hasher,
    HashForm,
};
use fe2o3_net::id::{
    Mid,
    Uid,
};
use std::{
    clone::Clone,
    collections::BTreeMap,
    fmt::Debug,
    net::{
        SocketAddr,
        UdpSocket,
    },
    sync::RwLock,
    time::{
        Duration,
        Instant,
    },
};
pub type MsgType = u16;
#[repr(u16)]
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum HandshakeType {
    Unknown = 0,
    Req1    = 1,
    Resp1   = 2,
    Req2    = 3,
    Resp2   = 4,
    Req3    = 5,
    Resp3   = 6,
}
impl From<MsgType> for HandshakeType {
    fn from(u: MsgType) -> Self {
        match u {
            1 =>    Self::Req1,
            2 =>    Self::Resp1,
            3 =>    Self::Req2,
            4 =>    Self::Resp2,
            5 =>    Self::Req3,
            6 =>    Self::Resp3,
            _ =>    Self::Unknown,
        }
    }
}
impl HandshakeType {
    pub fn is_hreq2(&self) -> bool {
        match self {
            Self::Req2 => true,
            _ => false,
        }
    }
}
pub trait IdentifiedMessage {
    fn typ(&self) -> MsgType;
    fn name(&self) -> &'static str;
}
pub struct MsgBuilder<
    H: Hasher + Send + 'static,
    const P0: usize,
    const P1: usize,
    PRIS: Pristine<P0, P1>,
    S: Signer,
> {
    pub chunk_cfg:  ChunkConfig,
    pub src_sock:   UdpSocket,
    pub trg_addr:   SocketAddr,
    pub validator:  PacketValidator<H, S>,
    pub powparams:  PowCreateParams<P0, P1, PRIS>,
}
pub struct Message;
impl Message {
    pub fn create<
        const MIDL: usize,
        const UIDL: usize,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
        H: Hasher + Send + 'static,
        const N: usize,
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
        S: Signer,
    >(
        msg_name:   &'static str,
        msg_byts:   Vec<u8>,
        typ:        MsgType,
        ver:        &SemVer,
        uid:        Uid<UIDL, UID>,
        chunker:    &Chunker,
        validator:  &PacketValidator<H, S>,
        powparams:  &PowCreateParams<P0, P1, PRIS>,
        inc_sigpk:  bool,
    )
        -> Outcome<(Vec<Vec<u8>>, Option<String>)>
    {
        trace!("{:?}", chunker);
        let size = chunker.cfg.chunk_size;
        let meta_len = PacketMeta::<MIDL, UIDL, MID, UID>::BYTE_LEN;
        let warning = if 2 * meta_len > size {
            Some(errmsg!("Message meta of length {} bytes is more than half \
                the specified packet size of {}. Consider increasing the \
                packet size.", meta_len, size,
            ))
        } else {
            None
        };
        let msg_len = msg_byts.len();
        let (mut chunks, _) = res!(chunker.chunk(&msg_byts));
        let nc = chunks.len();
        if nc > PacketCount::MAX as usize {
            return Err(err!(errmsg!("Message type {} of length {} bytes, \
                when broken into chunks of {} bytes creates {} packets, \
                exceeding the limit of {}.  Reduce the message length or \
                increase the packet size.",
                msg_name, msg_byts.len(), size, nc, PacketCount::MAX,
            ), Invalid, Configuration));
        }
        let mut packets = Vec::new();
        let mid = Mid::<MIDL, MID>::randef();
        for i in 0..nc {
            let chunk_len = chunks[i].len();
            let chnk = PacketChunkState {
                index:      res!(i.try_into()),
                num_chunks: res!(nc.try_into()),
                chunk_size: res!(chunk_len.try_into()),
                pad_last:   chunker.cfg.pad_last,
            };
            let meta = PacketMeta {
                typ,
                ver: *ver,
                mid,
                uid,
                chnk,
            };
            let mut packet = res!(meta.to_bytes(Vec::new()));
            let meta_len = packet.len();
            packet.append(&mut chunks[i]);
            let len = packet.len();
            packet = res!(validator.to_bytes::<N, P0, P1, PRIS>(
                packet,
                powparams,
                inc_sigpk,
            ));
            let validator_len = packet.len() - len;
            trace!("Packet {} lengths: msg {}, meta {} chunk {} valid {} total {}",
                i, msg_len, meta_len, chunk_len, validator_len, packet.len(),
            );
            trace!("  Chunk:      {}", chunks[i].len());
            packets.push(packet);
        }
        Ok((packets, warning))
    }
}
#[derive(Debug)]
pub struct MsgAssembler<
    const C: usize,
    M: MapMut<HashForm, MsgState> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
> {
    pub msgs: ShardMap<C, MsgState, M, H, S>,
}
impl<
    const C: usize,
    M: MapMut<HashForm, MsgState> + Clone + Debug,
    H: Hasher + Send + Sync + 'static,
    const S: usize,
>
    MsgAssembler<C, M, H, S>
{
    pub fn new(
        n:          u32,
        init_map:   M,
        hasher:     H,
        salt:       [u8; S],
    )
        -> Outcome<Self>
    {
        Ok(Self {
            msgs: res!(ShardMap::new(
                n,
                init_map,
                hasher,
                salt,
            )),
        })
    }
    pub fn get_locked_map<
        const MIDL: usize,
        MID: NumIdDat<MIDL>,
    >(
        &self,
        mid: &Mid<MIDL, MID>,
    )
        -> Outcome<(HashForm, &RwLock<M>)>
    {
        let key = res!(self.msgs.key(&res!(mid.to_byte_array())));
        let locked_map = res!(self.msgs.get_map_using_hash(&key));
        Ok((key, locked_map))
    }
    pub fn get_msg<
        const MIDL: usize,
        const UIDL: usize,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
    >(
        &self,
        meta:   &PacketMeta<MIDL, UIDL, MID, UID>,
        buf:    &[u8],
        params: &MsgAssemblyParams,
    )
        -> Outcome<(bool, Option<Vec<u8>>)>
    {
        let (key, locked_map) = res!(self.get_locked_map(&meta.mid));
        let mut unlocked_map = lock_write!(locked_map);
        if !unlocked_map.contains_key(&key) {
            unlocked_map.insert(key.clone(), MsgState::new(meta.chnk.num_chunks));
        }
        let (drop, msg_byt_opt) = match unlocked_map.get_mut(&key) {
            Some(mstat) => mstat.insert_part(
                meta,
                buf,
                params,
            ),
            None => return Ok((true, None)),
        };
        if drop || msg_byt_opt.is_some() {
            unlocked_map.remove(&key);
        }
        Ok((drop, msg_byt_opt))
    }
    pub fn remove<
        const MIDL: usize,
        MID: NumIdDat<MIDL>,
    >(
        &self,
        mid: &Mid<MIDL, MID>,
    )
        -> Outcome<()>
    {
        let (key, locked_map) = res!(self.get_locked_map(mid));
        let mut unlocked_map = lock_write!(locked_map);
        unlocked_map.remove(&key);
        Ok(())
    }
    pub fn message_assembly_garbage_collection(
        &self,
        params: &MsgAssemblyParams,
    )
        -> Outcome<()>
    {
        for i in 0..self.msgs.n {
            if let Some(locked_map) = &self.msgs.shards[i] {
                let mut unlocked_map = lock_write!(locked_map);
                unlocked_map.retain(
                    |_key, mstat|
                    !mstat.drop_on_time_check(params)
                )
            }
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MsgAssemblyParams {
    pub msg_sunset:     Duration,
    pub idle_max:       Duration,
    pub rep_tot_lim:    u8,
    pub rep_max_lim:    u8,
}
#[derive(Clone, Debug)]
pub struct MsgState {
    parts:      BTreeMap<PacketCount, (Vec<u8>, u8)>,
    tot:        PacketCount,
    cnt:        PacketCount,
    first:      Instant,
    last:       Instant,
    rep_tot:    u8,
    rep_max:    u8,
}
impl Default for MsgState {
    fn default() -> Self {
        Self {
            parts:      BTreeMap::new(),
            tot:        0,
            cnt:        0,
            first:      Instant::now(),
            last:       Instant::now(),
            rep_tot:    0,
            rep_max:    0,
        }
    }
}
impl MsgState {
    pub fn new(total_packets: PacketCount) -> Self {
        Self {
            tot: total_packets,
            cnt: total_packets,
            ..Default::default()
        }
    }
    pub fn insert_part<
        const MIDL: usize,
        const UIDL: usize,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
    >(
        &mut self,
        meta:   &PacketMeta<MIDL, UIDL, MID, UID>,
        buf:    &[u8],
        params: &MsgAssemblyParams,
    )
        -> (bool, Option<Vec<u8>>)
    {
        if self.cnt == self.tot {
            self.first = Instant::now();
        }
        if self.drop_on_time_check(params) {
            return (true, None);
        }
        self.last = Instant::now();
        match self.parts.get_mut(&meta.chnk.index) {
            Some((_part, n)) => {
                match n.checked_add(1) {
                    Some(n2) => if n2 > params.rep_max_lim {
                        return (true, None);
                    } else {
                        *n = n2;
                        self.rep_max = n2;
                    }
                    None => return (true, None),
                }
                match self.rep_tot.checked_add(1) {
                    Some(n2) => if n2 > params.rep_tot_lim {
                        return (true, None);
                    } else {
                        self.rep_tot = n2;
                    },
                    None => return (true, None),
                }
                return (false, None);
            },
            None => (),
        }
        self.parts.insert(meta.chnk.index, (buf.to_vec(), 0));
        if self.cnt == 1 {
            let mut v = Vec::new();
            for (_id, (part, _n)) in self.parts.iter_mut() {
                v.append(part);
            }
            return (false, Some(v));
        } else {
            self.cnt -= 1;
        }
        (false, None)
    }
    pub fn drop_on_time_check(
        &mut self,
        params: &MsgAssemblyParams,
    )
        -> bool
    {
        if self.first.elapsed() > params.msg_sunset ||
            self.last.elapsed() > params.idle_max
        {
            true
        } else {
            false
        }
    }
}
File: core.rs
use crate::{
    cfg::ShieldConfig,
    constant,
    guard::{
        addr::{
            AddressGuard,
            AddressLog,
        },
        data::{
            AddressData,
            UserData,
        },
        user::{
            UserGuard,
            UserLog,
        },
    },
    msg::{
        external::{
            MsgAssembler,
            MsgAssemblyParams,
            MsgBuilder,
            MsgState,
        },
        internal::{
            ServerMsg,
        },
    },
    packet::PacketValidator,
    pow::{
        DifficultyParams,
        PowPristine,
    },
    schemes::{
        WireSchemes,
        WireSchemesInput,
    },
    server::{
        RxEnv,
        ServerBot,
    },
};
use fe2o3_bot::{
    bot::Bot,
};
use fe2o3_core::{
    prelude::*,
    alt::Alt,
    channels::{
        simplex,
        Simplex,
    },
    thread::{
        Sentinel,
        thread_channel,
    },
};
use fe2o3_crypto::{
    sign::SignatureScheme,
};
use fe2o3_data::ring::RingTimer;
use fe2o3_iop_crypto::{
    enc::Encrypter,
    sign::{
        Signer,
        SignerDefAlt,
    },
};
use fe2o3_jdat::{
    cfg::Config,
    chunk::ChunkConfig,
    file::{
        JdatFile,
    },
    id::{
        NumId,
        NumIdDat,
    },
};
use fe2o3_hash::{
    hash::{
        HasherDefAlt,
        HashScheme,
    },
    map::ShardMap,
    pow::{
        PowCreateParams,
        PowVars,
        ProofOfWork,
    },
};
use fe2o3_iop_hash::{
    api::{
        Hasher,
        HashForm,
    },
    csum::Checksummer,
};
use fe2o3_net::id::{
    Mid,
    Sid,
    Uid,
};
use fe2o3_syntax::core::SyntaxRef;
use std::{
    collections::BTreeMap,
    marker::PhantomData,
    net::{
        IpAddr,
        SocketAddr,
        UdpSocket,
    },
    path::Path,
    sync::{
        Arc,
        Mutex,
        RwLock,
    },
    time::{
        Duration,
        Instant,
        SystemTime,
        UNIX_EPOCH,
    },
};
use local_ip_address::local_ip;
pub type BotId = NumId<8>;
#[derive(Clone, Debug)]
pub struct Protocol<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter,
> {
    pub cfg:    ShieldConfig,
    pub schms:  WireSchemes<WENC, WCS, POWH, SGN, HS>,
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter,
>
    Protocol<WENC, WCS, POWH, SGN, HS>
{
    pub fn new<P: AsRef<Path>>(
        cfg_opt:        Option<P>,
        schms_input:    WireSchemesInput<WENC, WCS, POWH, SGN, HS>,
    )
        -> Outcome<Self>
    {
        res!(ShieldConfig::check_constants());
        let mut cfg = match cfg_opt {
            Some(path) => res!(ShieldConfig::load(&path.as_ref())),
            None => {
                info!("No path to config file supplied: using default config.");
                ShieldConfig::default()
            },
        };
        res!(cfg.check_config());
        let no_chunker = schms_input.chnk.is_none();
        let mut schms = WireSchemes::from(schms_input);
        schms.powh = HasherDefAlt(res!(ShieldConfig::read_hash_scheme(
            &cfg.packet_pow_hash_scheme,
            &*HasherDefAlt::from(schms.powh),
            ShieldConfig::default_packet_pow_hash_scheme,
            "packet_pow_hash_scheme",
        )));
        schms.sign = SignerDefAlt(res!(ShieldConfig::read_signature_scheme(
            &cfg.packet_signature_scheme,
            &*SignerDefAlt::from(schms.sign),
            ShieldConfig::default_packet_signature_scheme,
            "packet_signature_scheme",
        )));
        if no_chunker {
            schms.chnk = cfg.chunk_config();
        }
        Ok(Self {
            cfg,
            schms,
        })
    }
}
pub struct ShieldParams<
    const BIDL: usize,
    const C: usize,
    const MIDL: usize,
    const SIDL: usize,
    const UIDL: usize,
    BID:    NumIdDat<BIDL> + 'static,
    MID:    NumIdDat<MIDL>,
    SID:    NumIdDat<SIDL> + 'static,
    UID:    NumIdDat<UIDL>,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
> {
    _code_template:     [u8; C],
    _mid_template:      Mid<MIDL, MID>,
    _sid_template:      Sid<SIDL, SID>,
    _uid_template:      Uid<UIDL, UID>,
    pub bid:            BotId<BIDL, BID>,
    pub schms_input:    WireSchemesInput<WENC, WCS, POWH, SGN, HS>,
}
impl<
    const BIDL: usize,
    const C: usize,
    const MIDL: usize,
    const SIDL: usize,
    const UIDL: usize,
    BID:    NumIdDat<BIDL> + 'static,
    MID:    NumIdDat<MIDL>,
    SID:    NumIdDat<SIDL> + 'static,
    UID:    NumIdDat<UIDL>,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
>
    ShieldParams<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>
{
    pub fn new(
        _code_template: [u8; C],
        _mid_template:  Mid<MIDL, MID>,
        _sid_template:  Sid<SIDL, SID>,
        _uid_template:  Uid<UIDL, UID>,
        bid:            BotId<BIDL, BID>,
        enc:            Option<WENC>,
        csum:           Option<WCS>,
        powh:           Option<POWH>,
        sign:           Option<SGN>,
        hsenc:          Option<HS>,
        chnk:           Option<ChunkConfig>,
        syntax:         SyntaxRef,
    )
        -> Self
    {
        Self {
            _code_template,
            _mid_template,
            _sid_template,
            _uid_template,
            bid,
            schms_input: WireSchemesInput {
                enc:    Alt::from(enc),
                csum:   Alt::from(csum),
                powh:   Alt::from(powh),
                sign:   Alt::from(sign),
                hsenc:  Alt::from(hsenc),
                chnk,
                syntax,
            },
        }
    }
}
pub struct Shield<
    const C: usize,
    const SIDL: usize,
    SID:    NumIdDat<SIDL>,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
> {
    pub addr:       IpAddr,
    pub addr_guard: Arc<AddressGuard<
                        { constant::AGRD_SHARDMAP_INIT_SHARDS },
                        BTreeMap<
                            HashForm,
                            AddressLog<
                                { constant::REQ_TIMER_LEN },
                                { constant::MAX_ALLOWED_AVG_REQ_PER_SEC },
                                AddressData,
                            >,
                        >,
                        HashScheme,
                        { constant::GUARD_SHARDMAP_SALT_LEN },
                        { constant::REQ_TIMER_LEN },
                        { constant::MAX_ALLOWED_AVG_REQ_PER_SEC },
                        AddressData,
                    >>,
    pub chan_in:    Simplex<ServerMsg>,
    pub port:       u16,
    pub protocol:   Protocol<WENC, WCS, POWH, SGN, HS>,
    pub sentinel:   Sentinel,
    pub socket:     UdpSocket,
    pub user_guard: Arc<UserGuard<
                        { constant::UGRD_SHARDMAP_INIT_SHARDS },
                        BTreeMap<
                            HashForm,
                            UserLog<UserData<SIDL, C, SID>>,
                        >,
                        HashScheme,
                        { constant::GUARD_SHARDMAP_SALT_LEN },
                        UserData<SIDL, C, SID>,
                    >>,
}
impl<
    const C: usize,
    const SIDL: usize,
    SID:    NumIdDat<SIDL> + 'static,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
>
    Shield<C, SIDL, SID, WENC, WCS, POWH, SGN, HS>
{
    pub fn params<
        const BIDL: usize,
        const MIDL: usize,
        const UIDL: usize,
        BID: NumIdDat<BIDL> + 'static,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
    >(
        code_template:  [u8; C],
        mid_template:   Mid<MIDL, MID>,
        sid_template:   Sid<SIDL, SID>,
        uid_template:   Uid<UIDL, UID>,
        bid:    BotId<BIDL, BID>,
        enc:    Option<WENC>,
        csum:   Option<WCS>,
        powh:   Option<POWH>,
        sign:   Option<SGN>,
        hsenc:  Option<HS>,
        chnk:   Option<ChunkConfig>,
        syntax: SyntaxRef,
    )
        -> ShieldParams<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>
    {
        ShieldParams::new(
            code_template,
            mid_template,
            sid_template,
            uid_template,
            bid,
            enc,
            csum,
            powh,
            sign,
            hsenc,
            chnk,
            syntax,
        )
    }
    pub fn new<
        const BIDL: usize,
        const MIDL: usize,
        const UIDL: usize,
        BID:    NumIdDat<BIDL> + 'static,
        MID:    NumIdDat<MIDL>,
        UID:    NumIdDat<UIDL>,
        P:      AsRef<Path>,
    >(
        cfg_opt:    Option<P>,
        params:     ShieldParams<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>,
    )
        -> Outcome<(
            Shield<C, SIDL, SID, WENC, WCS, POWH, SGN, HS>,
            ServerBot<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>,
        )>
    {
        let protocol = res!(Protocol::new(cfg_opt, params.schms_input));
        let port                = protocol.cfg.server_port_udp;
        let server_ip_addr      = res!(local_ip());
        let server_sock_addr    = SocketAddr::new(server_ip_addr.clone(), port);
        info!("Server ip address = {}", server_ip_addr);
        let server_sock = res!(UdpSocket::bind(server_sock_addr));
        let agrd_map_init = BTreeMap::<
            HashForm,
            AddressLog<
                { constant::REQ_TIMER_LEN },
                { constant::MAX_ALLOWED_AVG_REQ_PER_SEC },
                AddressData,
            >,
        >::new();
        let agrd = Arc::new(AddressGuard {
            amap: res!(ShardMap::<
                {constant::AGRD_SHARDMAP_INIT_SHARDS},
                _, _, _,
                {constant::GUARD_SHARDMAP_SALT_LEN},
            >::new(
                constant::AGRD_SHARDMAP_INIT_SHARDS as u32,
                agrd_map_init,
                res!(HashScheme::try_from("Seahash")),
                constant::SALT8,
            )),
            arps_max: constant::MAX_ALLOWED_AVG_REQ_PER_SEC,
            tint_min: constant::THROTTLED_INTERVAL_MIN,   
            tsunset: (
                constant::ADDR_THROTTLE_SUNSET_SECS_MIN,
                constant::ADDR_THROTTLE_SUNSET_SECS_MAX,
            ),
            blist_cnt: constant::THROTTLE_COUNT_BEFORE_BLACKLIST,
            hreq_exp: constant::SESSION_REQUEST_EXPIRY,
        });
        let ugrd_map_init = BTreeMap::<
            HashForm,
            UserLog<UserData<SIDL, C, SID>>,
        >::new();
        let ugrd = Arc::new(UserGuard {
            umap: res!(ShardMap::<
                {constant::UGRD_SHARDMAP_INIT_SHARDS},
                _, _, _,
                {constant::GUARD_SHARDMAP_SALT_LEN},
            >::new(
                constant::UGRD_SHARDMAP_INIT_SHARDS as u32,
                ugrd_map_init,
                res!(HashScheme::try_from("Seahash")),
                constant::SALT8,
            )),
        });
        let rxenv = RxEnv {
            timer:          Arc::new(RwLock::new(RingTimer::<{ constant::REQ_TIMER_LEN }>::default())),
            agrd:           agrd.clone(),
            ugrd:           ugrd.clone(),
            packval:        PacketValidator {
                                pow: Some(ProofOfWork::new(protocol.schms.powh.clone())),
                                sig: Some(protocol.schms.sign.clone()),
                            },
            gpzparams:      DifficultyParams {
                                profile:    constant::POW_DIFFICULTY_PROFILE,
                                max:        constant::POW_MAX_ZERO_BITS,
                                min:        constant::POW_MIN_ZERO_BITS,
                                rps_max:    constant::MAX_ALLOWED_AVG_REQ_PER_SEC,
                            },
            massembler:     Arc::new(res!(MsgAssembler::<
                                { constant::MSG_ASSEMBLY_SHARDS },
                                _, _,
                                {constant::GUARD_SHARDMAP_SALT_LEN},
                            >::new(
                                constant::MSG_ASSEMBLY_SHARDS as u32,
                                BTreeMap::<HashForm, MsgState>::new(),
                                res!(HashScheme::try_from("Seahash")),
                                constant::SALT8,
                            ))),
            ma_params:      MsgAssemblyParams {
                                msg_sunset:     constant::MSG_ASSEMBLY_SUNSET,
                                idle_max:       constant::MSG_ASSEMBLY_IDLE_MAX,
                                rep_tot_lim:    constant::MSG_ASSEMBLY_REP_TOTAL_LIM,
                                rep_max_lim:    constant::MSG_ASSEMBLY_REP_PACKET_LIM,
                            },
            pow_time_horiz: constant::POW_TIME_HORIZON_SEC,
            accept_unknown: true,
        };
        let (sem, sentinel) = thread_channel();
        let chan_in = simplex::<ServerMsg>();
        let server = ServerBot {
            id:         params.bid,
            protocol:   protocol.clone(),
            sem,
            errc:       Arc::new(Mutex::new(0)),
            inited:     false,
            chan_in:    chan_in.clone(),
            rxenv,
            pack_size:  constant::UDP_BUFFER_SIZE,
            sock:       res!(server_sock.try_clone()),
            sock_addr:  server_sock_addr.clone(),
            ma_gc_last: Instant::now(),
            ma_gc_int:  Duration::from_secs(300),
            phantom1:   PhantomData,
            phantom2:   PhantomData,
        };
        Ok((
            Shield {
                addr:       server_ip_addr,
                addr_guard: agrd,
                chan_in,
                port,
                protocol,
                socket:     server_sock,
                sentinel,
                user_guard: ugrd,
            },
            server,
        ))
    }
    pub fn start<
        const BIDL: usize,
        const MIDL: usize,
        const UIDL: usize,
        BID:    NumIdDat<BIDL> + 'static,
        MID:    NumIdDat<MIDL> + 'static,
        UID:    NumIdDat<UIDL> + 'static,
    >(
        &self,
        mut server: ServerBot<
            BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS,
        >,
    )
        -> Outcome<()>
    {
        res!(server.init());
        res!(server.start(self.sentinel.clone()));
        Ok(())
    }
    pub fn msg_builder_default (
        &self,
        code:   [u8; C],
        zbits:  u16,
    )
        -> Outcome<MsgBuilder<
            HasherDefAlt<HashScheme, POWH>,
            {constant::POW_PREFIX_LEN},
            {constant::POW_PREIMAGE_LEN},
            PowPristine<
                C,
                {constant::POW_PREFIX_LEN},
                {constant::POW_PREIMAGE_LEN},
            >,
            SignerDefAlt<SignatureScheme, SGN>,
        >>
    {
        let src_addr            = self.addr.clone();
        let server_sock_addr    = SocketAddr::new(src_addr.clone(), self.port);
        let server_sock         = res!(self.socket.try_clone());
        let pristine = PowPristine::<
            C,
            {constant::POW_PREFIX_LEN},
            {constant::POW_PREIMAGE_LEN},
        >{
            code,
            src_addr,
            timestamp: res!(SystemTime::now().duration_since(UNIX_EPOCH)),
            time_horiz: constant::POW_TIME_HORIZON_SEC,
        };
        trace!("POW Pristine tx:");
        res!(pristine.trace());
        Ok(MsgBuilder {
            chunk_cfg: ChunkConfig {
                threshold_bytes:    1_500,
                chunk_size:         1_000,
                dat_wrap:           false,
                pad_last:           true,
            },
            src_sock: res!(server_sock.try_clone()),
            trg_addr: server_sock_addr,
            validator: PacketValidator {
                pow: Some(ProofOfWork::new(self.protocol.schms.powh.clone())),
                sig: Some(self.protocol.schms.sign.clone()),
            },
            powparams: PowCreateParams {
                pvars: PowVars {
                    zbits,
                    pristine,
                },
                time_lim: constant::POW_CREATE_TIMEOUT,
                count_lim: constant::POW_CREATE_COUNT_LIM,
            },
        })
    }
}
File: keys.rs
use crate::{
    constant,
    id::Uid,
};
use fe2o3_core::{
    prelude::*,
    map::MapMut,
};
use fe2o3_crypto::{
    keys::KeyPair,
};
use fe2o3_jdat::id::NumIdDat;
use std::{
    fmt::Debug,
    marker::PhantomData,
    ops::Deref,
};
pub struct UserKeys<
    UID: NumIdDat<{constant::UID_LEN}>,
    M: MapMut<Uid<UID>, KeyPair> + Clone + Debug + Default,
>(
    pub M,
    PhantomData<UID>,
);
impl<
    UID: NumIdDat<{constant::UID_LEN}>,
    M: MapMut<Uid<UID>, KeyPair> + Clone + Debug + Default,
>
    Deref for UserKeys<UID, M>
{
    type Target = M;
    fn deref(&self) -> &Self::Target { &self.0 }
}
File: session.rs
File: constant.rs
use crate::{
    cfg::ShieldConfig,
    msg::external::MsgType,
    pow::DifficultyProfile,
};
use fe2o3_core::{
    prelude::*,
    byte::Encoding,
};
use fe2o3_jdat::{
    prelude::*,
    version::SemVer,
};
use std::{
    mem,
    time::Duration,
};
impl ShieldConfig {
    pub fn check_constants() -> Outcome<()> {
        Ok(())
    }
}
pub const VERSION:                          SemVer = SemVer::new(0, 5, 0);
pub const STACK_SIZE:                       usize = 2 * 1024 * 1024;
pub const UDP_BUFFER_SIZE:                  usize = 1_400;
pub const POW_CREATE_TIMEOUT:               Duration = Duration::from_secs(30);
pub const POW_CREATE_COUNT_LIM:             usize = usize::MAX;
pub const POW_TIME_HORIZON_SEC:             u64 = 600;
pub const DEFAULT_UDP_PACKET_SIZE:          usize = 700;
pub const REQ_TIMER_LEN:                    usize = 100;
pub const MAX_ALLOWED_AVG_REQ_PER_SEC:      u64 = 30;
pub const POW_DIFFICULTY_PROFILE:           DifficultyProfile = DifficultyProfile::Linear;
pub const POW_MAX_ZERO_BITS:                u16 = 30;
pub const POW_MIN_ZERO_BITS:                u16 = 0;
pub const POW_NONCE_LEN:                    usize = 8;
pub const POW_CODE_LEN:                     usize = 8;
pub const POW_ADDR_LEN:                     usize = 16;
pub const POW_TIMESTAMP_LEN:                usize = 8;
pub const POW_PREFIX_LEN: usize = 
    POW_ADDR_LEN
    + POW_CODE_LEN;
pub const POW_PREIMAGE_LEN: usize = 
    POW_ADDR_LEN
    + POW_CODE_LEN
    + POW_TIMESTAMP_LEN;
pub const POW_INPUT_LEN: usize = 
    POW_PREIMAGE_LEN
    + POW_NONCE_LEN;
pub const THROTTLED_INTERVAL_MIN:           Duration = Duration::from_secs(1);
pub const ADDR_THROTTLE_SUNSET_SECS_MIN:    u64 = 1_800;
pub const ADDR_THROTTLE_SUNSET_SECS_MAX:    u64 = 259_200;
pub const THROTTLE_COUNT_BEFORE_BLACKLIST:  u16 = 10;
pub const SESSION_REQUEST_EXPIRY:           Duration = Duration::from_secs(600);
pub const PARTIAL_MESSAGE_SUNSET:           Duration = Duration::from_secs(600);
pub const MSG_ASSEMBLY_SUNSET:              Duration = Duration::from_secs(600);
pub const MSG_ASSEMBLY_IDLE_MAX:            Duration = Duration::from_secs(60);
pub const MSG_ASSEMBLY_REP_TOTAL_LIM:       u8 = 128;
pub const MSG_ASSEMBLY_REP_PACKET_LIM:      u8 = 32;
pub const MSG_ASSEMBLY_GC_INTERVAL:         Duration = Duration::from_secs(600);
pub const MSG_ASSEMBLY_SHARDS:              usize = 10;
pub const DEFAULT_MSG_ENCODING:             Encoding = Encoding::Binary;
pub const UGRD_SHARDMAP_INIT_SHARDS:        usize = 10;
pub const AGRD_SHARDMAP_INIT_SHARDS:        usize = 10;
pub const GUARD_SHARDMAP_SALT_LEN:          usize = 8;
pub const SESSION_ID_KIND:                  Kind = Kind::U64;
pub const MSG_TYPE_BYTE_LEN:                usize = mem::size_of::<MsgType>();
pub const SERVER_INT_CHANNEL_CHECK_INTERVAL:    Duration = Duration::from_nanos(1_000);
pub const SERVER_EXT_SOCKET_CHECK_INTERVAL:     Duration = Duration::from_nanos(999_000);
pub const SERVER_BOT_ERROR_COUNT_WARNING:   usize = 10;
pub const MIN_CHUNK_SIZE:               usize = (9 + 12)*2;
pub const USER_PASS_HASH_SALT_LEN: usize = 16;
pub const SALT8: [u8; 8] = [
    0x15, 0x04, 0x84, 0x1e, 0xf2, 0x07, 0x19, 0xbc,
];
pub const SALT16: [u8; 16] = [
    0xc9, 0x48, 0xcc, 0xbe, 0xd5, 0xd1, 0x16, 0x6c,
    0xc2, 0x2a, 0x78, 0x85, 0xce, 0x3e, 0x25, 0xcd,
];
pub const SALT32: [u8; 32] = [
    0xbd, 0xd5, 0x81, 0xba, 0x0c, 0xeb, 0x4f, 0xad,
    0x23, 0x72, 0xd4, 0xac, 0x92, 0xeb, 0xa6, 0x6f,
    0xf9, 0x65, 0x4f, 0x04, 0xca, 0xd5, 0x8b, 0x73,
    0xb2, 0xfa, 0x72, 0x39, 0x21, 0x6b, 0x6c, 0x5f,
];
File: pow.rs
pub use fe2o3_core::{
    prelude::*,
    rand::Rand,
};
use fe2o3_hash::pow::{
    Pristine,
    ZeroBits
};
use std::{
    net::{
        IpAddr,
        Ipv4Addr,
    },
    time::{
        Duration,
        SystemTime,
    },
};
#[repr(u8)]
#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub enum DifficultyProfile {
    Linear  = 0,
}
impl TryFrom<u8> for DifficultyProfile {
    type Error = Error<ErrTag>;
    fn try_from(n: u8) -> std::result::Result<Self, Self::Error> {
        match n {
            0 => Ok(Self::Linear),
            _ => Err(err!(errmsg!(
                "'{}' not recognised as a valid server_rps_zbits_profile configuration value, \
                use a value in the range 0..0.", n,
            ), Invalid, Input)),
        }
    }
}
#[derive(Clone, Debug)]
pub struct DifficultyParams {
    pub profile:    DifficultyProfile,
    pub max:        u16,
    pub min:        u16,
    pub rps_max:    u64,
}
impl DifficultyParams {
    #[inline(always)]
    pub fn required_global_zbits(&self, rps: u16) -> Outcome<ZeroBits> {
        match self.profile {
            DifficultyProfile::Linear => Ok(
                ((((self.max - self.min) * rps)
                / self.max) + self.min) as ZeroBits
            ),
        }
    }
}
#[derive(Clone, Debug)]
pub struct PowPristine<
    const C: usize,
    const P0: usize,
    const P1: usize,
> {
    pub code:       [u8; C],
    pub src_addr:   IpAddr,
    pub timestamp:  Duration,
    pub time_horiz: u64,
}
impl<
    const C: usize,
    const P0: usize,
    const P1: usize,
>
    Default for PowPristine<C, P0, P1>
{
    fn default() -> Self {
        Self {
            code:       [0; C],
            src_addr:   IpAddr::V4(Ipv4Addr::UNSPECIFIED),
            timestamp:  Duration::ZERO,
            time_horiz: 600,
        }
    }
}
impl<
    const C: usize,
    const P0: usize,
    const P1: usize,
>
    Pristine<P0, P1> for PowPristine<C, P0, P1>
{
    fn to_bytes(&self) -> Outcome<[u8; P1]> {
        let mut byts = [0u8; P1];
        let mut i = res!(self.prefix(&mut byts));
        let t = self.timestamp.as_secs().to_be_bytes();
        for b in t {
            byts[i] = b;
            i += 1;
        }
        Ok(byts)
    }
    fn prefix(&self, byts: &mut [u8]) -> Outcome<usize> {
        if byts.len() < Self::PREFIX_BYTE_LEN {
            return Err(err!(errmsg!(
                "Cannot fit {} address bytes into given slice of length {}.",
                Self::PREFIX_BYTE_LEN, byts.len(), 
            ), Bug, Input, TooSmall));
        }
        let mut i: usize = 0;
        let addr = self.src_addr;
        match addr {
            IpAddr::V4(addr) => {
                for _ in 0..4 {
                    for b in addr.octets() {
                        byts[i] = b;
                        i += 1;
                    }
                }
            },
            IpAddr::V6(addr) => {
                for b in addr.octets() {
                    byts[i] = b;
                    i += 1;
                }
            },
        }
        for b in self.code {
            byts[i] = b;
            i += 1;
        }
        Ok(Self::PREFIX_BYTE_LEN)
    }
    fn timestamp_valid(&self, artefact: &[u8]) -> Outcome<bool> {
        if artefact.len() < Self::TIMESTAMP_LEN {
            return Err(err!(errmsg!(
                "Artefact slice length {} must be at least a timestamp length, {}.",
                artefact.len(), Self::TIMESTAMP_LEN,
            ), Input, TooSmall));
        }
        let t0 = u64::from_be_bytes(
            res!(<[u8; 8]>::try_from(&artefact[..8]), Decode, Bytes)
        );
        let t1 = res!(SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)).as_secs();
        if t0 > t1 {
            Ok(false)
        } else {
            Ok((t1 - t0) < self.time_horiz)
        }
    }
}
impl<
    const C: usize,
    const P0: usize,
    const P1: usize,
>
    PowPristine<C, P0, P1>
{
    pub const TIMESTAMP_LEN:    usize = 8;
    pub const ADDR_LEN:         usize = 16;
    pub fn new_rx(
        code:       [u8; C],
        src_addr:   IpAddr,
        time_horiz: u64,
    )
        -> Outcome<Self>
    {
        if P0 >= P1 {
            return Err(err!(errmsg!(
                "The pristine prefix length {} must be less than the pristine length, {}.",
                P0, P1,
            ), Input, Mismatch));
        }
        Ok(Self {
            code,
            src_addr,
            timestamp:  Duration::ZERO,
            time_horiz,
        })
    }
    pub fn trace(&self) -> Outcome<()> {
        let byts = res!(self.to_bytes());
        trace!("\nPrefix   [{:>4}]: {:02x?}\
            \n  Addr   [{:>4}]: {:02x?}\
            \n  Code   [{:>4}]: {:02x?}\
            \nArtefact [{:>4}]: {:02x?}\
            \n  Time   [{:>4}]: {:02x?}",
            P0, &byts[..P0],
            P0-C, &byts[..P0-C],
            C, self.code,
            P1-P0, &byts[P0..],
            P1-P0, &byts[P0..],
        );
        Ok(())
    }
}
File: cfg.rs
use crate::{
    constant,
    msg::syntax,
    packet::PacketValidator,
    schemes::{
        WireSchemes,
    },
};
use fe2o3_core::{
    prelude::*,
    alt::DefAlt,
};
use fe2o3_crypto::sign::SignatureScheme;
use fe2o3_iop_crypto::{
    sign::{
        Signer,
        SignerDefAlt,
    },
    enc::Encrypter,
};
use fe2o3_jdat::{
    prelude::*,
    cfg::Config,
    chunk::{
        Chunker,
        ChunkConfig,
    },
    file::JdatFile,
};
use fe2o3_hash::{
    hash::{
        HashScheme,
        HasherDefAlt,
    },
    pow::ProofOfWork,
};
use fe2o3_iop_hash::{
    api::Hasher,
    csum::Checksummer,
};
use fe2o3_syntax::core::SyntaxRef;
use std::{
    collections::BTreeMap,
};
#[derive(Clone, Debug, Eq, PartialEq, FromDatMap, ToDatMap)]
pub struct ShieldConfig {
    pub schemes_db_path:                String,
    pub wire_chunk_threshold:           u64,
    pub wire_chunk_bytes:               u64,
    pub server_address:                 String,
    pub server_port_udp:                u16,
    pub server_port_tcp:                u16,
    pub server_rps_zbits_profile:       u8,
    pub server_pow_zbits_min:           u16,
    pub server_pow_zbits_max:           u16,
    pub server_pow_time_horiz_secs:     u64,
    pub server_rps_max:                 u16,
    pub packet_pow_hash_scheme:         String,
    pub packet_signature_scheme:        String,
    pub addr_guard_map_bins:            u32,
    pub user_guard_map_bins:            u32,
    pub msg_assembler_map_bins:         u32,
    pub server_accept_unknown_users:    bool,
}
impl Config for ShieldConfig {
    fn check_config(&mut self) -> Outcome<()> {
        res!(self.check_wire_chunk_config(&self.chunk_config()));
        Ok(())
    }
}
impl Default for ShieldConfig {
    fn default() -> Self {
        Self {
            schemes_db_path:                fmt!("../fe2o3_namex/namex.jdat"),
            wire_chunk_threshold:           1_500,
            wire_chunk_bytes:               1_000,
            server_address:                 fmt!("127.0.0.1"),
            server_port_udp:                60000,
            server_port_tcp:                60000,
            server_rps_zbits_profile:       0,
            server_pow_zbits_min:           2,
            server_pow_zbits_max:           15,
            server_pow_time_horiz_secs:     600,
            server_rps_max:                 30_000,
            packet_pow_hash_scheme:         fmt!("Seahash"),
            packet_signature_scheme:        fmt!("Ed25519"),
            addr_guard_map_bins:            128,
            user_guard_map_bins:            128,
            msg_assembler_map_bins:         128,
            server_accept_unknown_users:    false,
        }
    }
}
impl ShieldConfig {
    pub fn try_default() -> Outcome<Self> {
        Ok(Self::default())
    }
    pub fn syntax_default() -> Outcome<SyntaxRef> {
        let syntax = SyntaxRef(Arc::new(res!(syntax::build())));
        Ok(syntax)
    }
    pub fn default_packet_pow_hash_scheme() -> Option<HashScheme> {
        Some(HashScheme::new_seahash())
    }
    pub fn default_packet_signature_scheme() -> Option<SignatureScheme> {
        Some(SignatureScheme::empty_ed25519())
    }
    pub fn update_packet_validator<
	    WENC: Encrypter,
	    WCS: Checksummer,
        POWH: Hasher,
	    SGN: Signer,
	    HS: Encrypter,
    >(
        &self,
        wschms: &WireSchemes<WENC, WCS, POWH, SGN, HS>,
    )
        -> Outcome<PacketValidator<
            HasherDefAlt<HashScheme, POWH>,
            SignerDefAlt<SignatureScheme, SGN>,
        >>
    {
        let pow_def_alt = res!(Self::read_hash_scheme(
            &self.packet_pow_hash_scheme,
            &*wschms.powh,
            Self::default_packet_pow_hash_scheme,
            "packet_pow_hash_scheme",
        ));
        let sig_def_alt = res!(Self::read_signature_scheme(
            &self.packet_signature_scheme,
            &*wschms.sign,
            Self::default_packet_signature_scheme,
            "packet_signature_scheme",
        ));
        Ok(PacketValidator { 
            pow: match pow_def_alt {
                DefAlt::Given(..) | DefAlt::Default(..) =>
                    Some(ProofOfWork::new(HasherDefAlt(pow_def_alt))),
                DefAlt::None => None,
            },
            sig: match sig_def_alt {
                DefAlt::Given(..) | DefAlt::Default(..) =>
                    Some(SignerDefAlt(sig_def_alt)),
                DefAlt::None => None,
            },
        })
    }
    pub fn chunk_config(&self) -> ChunkConfig {
        ChunkConfig {
            threshold_bytes:    self.wire_chunk_threshold as usize,
            chunk_size:         self.wire_chunk_bytes as usize, 
            dat_wrap:           false,
            pad_last:           true,
        }
    }
    pub fn chunker(cfg: ChunkConfig) -> Chunker {
        Chunker::default().set_config(cfg)
    }
    pub fn wire_chunk_size(&self)           -> usize { self.wire_chunk_bytes as usize }
    pub fn wire_chunking_threshold(&self)   -> usize { self.wire_chunk_threshold as usize }
    pub fn new_chunk_cfg(
        threshold_bytes:    usize,
        chunk_size:         usize,
        dat_wrap:           bool,
        pad_last:           bool,
    )
        -> ChunkConfig
    {
        ChunkConfig {
            threshold_bytes,
            chunk_size,
            dat_wrap,
            pad_last,
        }
    }
    pub fn chunker_default(&self) -> ChunkConfig {
        ChunkConfig {
            threshold_bytes:    self.wire_chunk_threshold as usize,
            chunk_size:         self.wire_chunk_bytes as usize,
            dat_wrap:           false,
            pad_last:           true,
        }
    }
    pub fn check_wire_chunk_config(&self, chunk_cfg: &ChunkConfig) -> Outcome<()> {
        if chunk_cfg.chunk_size > u16::MAX as usize {
            return Err(err!(errmsg!(
                "Chunk size of {} is less than the current minimum of {}.",
                chunk_cfg.chunk_size, constant::MIN_CHUNK_SIZE,
            ), TooBig, Configuration));
        }
        Ok(())
    }
    pub fn dump(self) -> Outcome<()> {
        let dat = Self::to_datmap(self);
        for line in dat.to_lines("    ", true) {
            info!("{}", line);
        }
        Ok(())
    }
    pub fn addr_guard_map_bins(&self) -> u32 {
        self.addr_guard_map_bins
    }
    pub fn user_guard_map_bins(&self) -> u32 {
        self.user_guard_map_bins
    }
    pub fn msg_assembler_map_bins(&self) -> u32 {
        self.msg_assembler_map_bins
    }
}
File: server.rs
use crate::{
    constant,
    core::Protocol,
    guard::{
        addr::{
            AddressGuard,
            AddressLog,
        },
        data::{
            AddressData,
            UserData,
        },
        user::{
            UserGuard,
            UserLog,
        },
    },
    msg::{
        external::{
            MsgAssemblyParams,
            MsgAssembler,
            MsgState,
        },
        internal::ServerMsg,
        syntax::{
            HReq1,
            MsgFmt,
            MsgIds,
            MsgPow,
        },
    },
    packet::{
        PacketMeta,
        PacketValidationArtefactRelativeIndices,
        PacketValidator,
    },
    pow::{
        PowPristine,
        DifficultyParams,
    },
};
use fe2o3_bot::{
    id::BotId,
    bot::{
        Bot,
        LoopBreak,
    },
    handles::Handle,
};
use fe2o3_core::{
    prelude::*,
    byte::{
        FromBytes,
    },
    channels::{
        Simplex,
        Recv,
    },
    thread::{
        Semaphore,
        Sentinel,
    },
};
use fe2o3_crypto::{
    sign::SignatureScheme,
    keys::PublicKey,
};
use fe2o3_data::ring::RingTimer;
use fe2o3_iop_crypto::{
    enc::{
        Encrypter,
    },
    keys::KeyManager,
    sign::{
        Signer,
        SignerDefAlt,
    },
};
use fe2o3_hash::{
    hash::{
        HasherDefAlt,
        HashScheme,
    },
    pow::PowVars,
};
use fe2o3_iop_hash::{
    api::{
        Hasher,
        HashForm,
    },
    csum::Checksummer,
};
use fe2o3_jdat::id::NumIdDat;
use fe2o3_namex::id::InNamex;
use fe2o3_syntax::{
    core::SyntaxRef,
    msg::{
        Msg as SyntaxMsg,
    },
};
use fe2o3_text::string::Stringer;
use std::{
    collections::BTreeMap,
    io,
    marker::PhantomData,
    net::{
        SocketAddr,
        UdpSocket,
    },
    sync::{
        Arc,
        Mutex,
        RwLock,
    },
    thread,
    time::{
        Duration,
        Instant,
    },
};
use tokio::task;
#[derive(Clone, Debug)]
pub struct RxEnv<
    const C: usize,
    const SIDL: usize,
    SID:    NumIdDat<SIDL>,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
>{
    pub timer:          Arc<RwLock<RingTimer<{ constant::REQ_TIMER_LEN }>>>,
    pub agrd:           Arc<AddressGuard<
                            { constant::AGRD_SHARDMAP_INIT_SHARDS },
                            BTreeMap<
                                HashForm,
                                AddressLog<
                                    { constant::REQ_TIMER_LEN },
                                    { constant::MAX_ALLOWED_AVG_REQ_PER_SEC },
                                    AddressData,
                                >,
                            >,
                            HashScheme,
                            { constant::GUARD_SHARDMAP_SALT_LEN },
                            { constant::REQ_TIMER_LEN },
                            { constant::MAX_ALLOWED_AVG_REQ_PER_SEC },
                            AddressData,
                        >>,
    pub ugrd:           Arc<UserGuard<
                            { constant::UGRD_SHARDMAP_INIT_SHARDS },
                            BTreeMap<
                                HashForm,
                                UserLog<UserData<SIDL, C, SID>>,
                            >,
                            HashScheme,
                            { constant::GUARD_SHARDMAP_SALT_LEN },
                            UserData<SIDL, C, SID>,
                        >>,
    pub packval:        PacketValidator<
                            HasherDefAlt<HashScheme, POWH>,
                            SignerDefAlt<SignatureScheme, SGN>,
                        >,
    pub gpzparams:      DifficultyParams,
    pub massembler:     Arc<MsgAssembler<
                            { constant::MSG_ASSEMBLY_SHARDS },
                            BTreeMap<HashForm, MsgState>,
                            HashScheme,
                            { constant::GUARD_SHARDMAP_SALT_LEN },
                        >>,
    pub ma_params:      MsgAssemblyParams,
    pub pow_time_horiz: u64,
    pub accept_unknown: bool,
}
impl<
    const C: usize,
    const SIDL: usize,
    SID:    NumIdDat<SIDL>,
	POWH:   Hasher,
	SGN:    Signer,
>
    RxEnv<C, SIDL, SID, POWH, SGN>
{
    pub async fn process<
        const MIDL: usize,
        const UIDL: usize,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
    >(
        self,
        buf:        [u8; constant::UDP_BUFFER_SIZE], 
        n:          usize,
        src_addr:   SocketAddr,
        syntax:     SyntaxRef,
    )
        -> Outcome<()>
    {
        let src_addr_str = fmt!("{:?}", src_addr);
        match self.get_process_result::<MIDL, UIDL, MID, UID>(buf, n, src_addr, syntax) {
            Err(e) => {
                let e2 = err!(e, fmt!("While processing incoming packet from {}.", src_addr_str));
                error!(e2.clone());
                Err(e2)
            },
            Ok(()) => {
                Ok(())
            },
        }
    }
    fn get_process_result<
        const MIDL: usize,
        const UIDL: usize,
        MID: NumIdDat<MIDL>,
        UID: NumIdDat<UIDL>,
    >(
        mut self,
        buf:        [u8; constant::UDP_BUFFER_SIZE], 
        n:          usize,
        src_addr:   SocketAddr,
        syntax:     SyntaxRef,
    )
        -> Outcome<()>
    {
        {
            let mut unlocked_timer = lock_write!(self.timer);
            unlocked_timer.update();
        }
        debug!("incoming [{}]:", n);
        for line in dump!(" {:02x}", &buf[..n], 32) {
            debug!("{}", line);
        }
        let (meta, n1) = res!(PacketMeta::<MIDL, UIDL, MID, UID>::from_bytes(&buf[..n]));
        debug!("meta [{}]:", n1);
        for line in Stringer::new(fmt!("{:?}", meta)).to_lines("  ") {
            debug!("{}", line);
        }
        if res!(self.agrd.drop_packet(meta.typ, &src_addr)) {
            debug!("Address guard dropping packet.");
            return Ok(());
        }
        if res!(self.ugrd.drop_packet(&meta.uid, self.accept_unknown)) {
            debug!("User guard dropping packet.");
            return Ok(());
        }
        debug!("");
        let n2 = n1 + (meta.chnk.chunk_size as usize);
        let (afact_rel_ind, _) =
            res!(PacketValidationArtefactRelativeIndices::from_bytes(&buf[n2..n]));
        let (akey, locked_amap) = res!(self.agrd.get_locked_map(&src_addr));
        let (ukey, locked_umap) = res!(self.ugrd.get_locked_map(&meta.uid));
        debug!("");
        let powvars = match self.packval.pow {
            Some(..) => {
                let zbits = {
                    let unlocked_amap = lock_read!(locked_amap);
                    if let Some(alog) = unlocked_amap.get(&akey) {
                        let unlocked_timer = lock_read!(self.timer);
                        let zbits = res!(
                            self.gpzparams.required_global_zbits(unlocked_timer.avg_rps() as u16),
                            IO,
                        );
                        if zbits >= alog.data.my_zbits {
                            zbits
                        } else {
                            alog.data.my_zbits
                        }
                    } else {
                        return Err(err!(errmsg!(
                            "No AddressLog entry for {:?}, which should have been created \
                            by the AddressGuard::drop_packet call.", src_addr,
                        ), Bug, Missing));
                    }
                };
                let code = {
                    let unlocked_umap = lock_read!(locked_umap);
                    if let Some(ulog) = unlocked_umap.get(&ukey) {
                        ulog.data.code.clone().unwrap_or([0; C])
                    } else {
                        return Err(err!(errmsg!(
                            "No UserLog entry for {:?}, which should have been created \
                            by the UserGuard::drop_packet call.", meta.uid,
                        ), Bug, Missing));
                    }
                };
                let pristine = res!(PowPristine::<
                    C,
                    {constant::POW_PREFIX_LEN},
                    {constant::POW_PREIMAGE_LEN},
                >::new_rx(
                    code,
                    src_addr.ip(),
                    self.pow_time_horiz, 
                ));
                trace!("POW Pristine rx:");
                res!(pristine.trace());
                Some(PowVars {
                    zbits,
                    pristine,
                })
            },
            _  => None,
        };
        match &mut self.packval.sig {
            Some(signer) => {
                let unlocked_umap = lock_read!(locked_umap);
                if let Some(ulog) = unlocked_umap.get(&ukey) {
                    let signer_nid = signer.local_id();
                    match &ulog.data.sigtpk_opt {
                        Some(sigtpk) => {
                            if sigtpk.sts.id != signer_nid {
                                return Err(err!(errmsg!(
                                    "Local scheme id, {:?}, for public signing key of user, {:02x?}, does not \
                                    match the nid for the current packet signing scheme, {:?}.",
                                    sigtpk.sts.id, meta.uid, signer_nid,
                                )));
                            }
                            *signer = res!(signer.clone_with_keys(Some(&sigtpk.key[..]), None));
                        },
                        None => (),
                    }
                } else {
                    return Err(err!(errmsg!(
                        "No UserLog entry for {:02x?}, which should have been created \
                        by the UserGuard::drop_packet call.", meta.uid,
                    ), Bug, Missing));
                }
            },
            _ => (),
        }
        match &afact_rel_ind.pow {
            Some(range) => {
                let artefact = &buf[n2 + range.start..n2 + range.end];
                trace!("POW rx:");
                res!(self.packval.trace(
                    powvars.as_ref(),
                    artefact,
                ));
            },
            None => return Err(err!(errmsg!(
                "Proof of work validation missing artefact.",
            ), Bug, Configuration, Missing)),
        }
        let validation = res!(self.packval.validate(
            &buf[..n],
            n2,
            afact_rel_ind,
            powvars,
            meta.typ,
        ));
        debug!("{:?}", validation);
        let validity = fmt!("pow {} sig {}", validation.pow_state(), validation.sig_state());
        match validation.is_valid() {
            Some((valid, sigpk_opt)) => if !valid {
                trace!("Dropping packet: {}", validity);
                return Ok(());
            } else {
                debug!("The packet is valid: {}", validity);
                match sigpk_opt {
                    Some((nid, sigpk_given)) => {
                        let mut unlocked_umap = lock_write!(locked_umap);
                        if let Some(ulog) = unlocked_umap.get_mut(&ukey) {
                            match &ulog.data.sigtpk_opt {
                                Some(sigtpk) => {
                                    if sigtpk.key != sigpk_given {
                                        ulog.data.sigtpk_opt_old = Some(sigtpk.clone());
                                    } else {
                                        match &ulog.data.sigtpk_opt_old {
                                            Some(_sigtpk_old) => {
                                                if let Some(pk) = ulog.data.pack_sigpk_set.first() {
                                                    ulog.data.sign_pack_this = Some(pk.key.clone());
                                                }
                                            },
                                            None => {
                                                if self.accept_unknown {
                                                    ulog.data.sigtpk_opt = Some(res!(PublicKey::now(
                                                        nid,
                                                        sigtpk.key.clone(),
                                                    )));
                                                } else {
                                                    return Ok(());
                                                }
                                            },
                                        }
                                    }
                                },
                                None => (),
                            }
                        } else {
                            return Err(err!(errmsg!(
                                "No UserLog entry for {:?}, which should have been created \
                                by the UserGuard::drop_packet call.", meta.uid,
                            ), Bug, Missing));
                        }
                    },
                    None => (),
                }
            },
            None => (),
        }
        debug!("");
        match res!(self.massembler.get_msg(
            &meta,
            &buf[n1..n2],
            &self.ma_params,
        )) {
            (false, None) => return Ok(()),
            (false, Some(msg_byts)) => {
                let msgrx = SyntaxMsg::new(syntax.clone());
                let mut msgrx = res!(msgrx.from_bytes(&msg_byts));
                debug!("msgrx [{}]: {}", msg_byts.len(), msgrx);
                let msgids: MsgIds<SIDL, UIDL, SID, UID> = res!(MsgIds::from_msg(
                    meta.uid,
                    &mut msgrx,
                ));
                let msgpow = res!(MsgPow::from_msg(&mut msgrx));
                let msgfmt = MsgFmt {
                    syntax: syntax.clone(),
                    encoding: constant::DEFAULT_MSG_ENCODING,
                };
                for (cmd_name, mut msgcmd) in msgrx.cmds {
                    match cmd_name.as_str() {
                        "hreq1" => {
                            debug!("HREQ1");
                            let mut scmd: HReq1<SIDL, UIDL, SID, UID> = HReq1 {
                                fmt: msgfmt.clone(),
                                pow: msgpow.clone(),
                                mid: msgids.clone(),
                                ..Default::default()
                            };
                            let mut unlocked_amap = lock_write!(locked_amap);
                            if let Some(alog) = unlocked_amap.get_mut(&akey) {
                                    res!(scmd.server_process(
                                        &mut msgcmd,
                                        &mut alog.data,
                                    ));
                            }
                        },
                        _ => return Err(err!(errmsg!(
                            "Unrecognised message command '{}'.", cmd_name,
                        ), Bug, Unimplemented)),
                    }
                }
            },
            (true, _) => {
                res!(self.massembler.remove(&meta.mid));
            },
        }
        Ok(())
    }
}
#[derive(Debug)]
pub struct ServerBot<
    const BIDL: usize,
    const C: usize,
    const MIDL: usize,
    const SIDL: usize,
    const UIDL: usize,
    BID:    NumIdDat<BIDL>,
    MID:    NumIdDat<MIDL>,
    SID:    NumIdDat<SIDL>,
    UID:    NumIdDat<UIDL>,
	WENC:   Encrypter,
	WCS:    Checksummer,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter,
> {
    pub id:         BotId<BIDL, BID>,
    pub protocol:   Protocol<WENC, WCS, POWH, SGN, HS>,
    pub sem:        Semaphore,
    pub errc:       Arc<Mutex<usize>>,
    pub inited:     bool,
    pub chan_in:    Simplex<ServerMsg>,
    pub rxenv:      RxEnv<C, SIDL, SID, POWH, SGN>,
    pub pack_size:  usize,
    pub sock:       UdpSocket,
    pub sock_addr:  SocketAddr,
    pub ma_gc_last: Instant,
    pub ma_gc_int:  Duration,
    pub phantom1:   PhantomData<MID>,
    pub phantom2:   PhantomData<UID>,
}
impl<
    const BIDL: usize,
    const C: usize,
    const MIDL: usize,
    const SIDL: usize,
    const UIDL: usize,
    BID:    NumIdDat<BIDL> + 'static,
    MID:    NumIdDat<MIDL> + 'static,
    SID:    NumIdDat<SIDL> + 'static,
    UID:    NumIdDat<UIDL> + 'static,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
>
    Bot<BIDL, BID, ServerMsg> for
    ServerBot<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>
{
    fn id(&self)        -> &BotId<BIDL, BID> { &self.id }
    fn errc(&self)      -> &Arc<Mutex<usize>> { &self.errc }
    fn chan_in(&self)   -> &Simplex<ServerMsg> { &self.chan_in }
    fn label(&self)     -> String { fmt!("Shield Server {:?}", self.id()) }
    fn err_count_warning(&self) -> usize { constant::SERVER_BOT_ERROR_COUNT_WARNING }
    fn set_chan_in(&mut self, chan_in: Simplex<ServerMsg>) {
        self.chan_in = chan_in;
    }
    fn init(&mut self) -> Outcome<()> {
        info!("{}: Now listening on UDP at {:?}.",
            self.label(), res!(self.sock.local_addr()),
        );
        self.inited = true;
        Ok(())
    }
    fn go(&mut self) {
        if !self.inited {
            error!(err!(errmsg!(
                "Attempt to start {} before running init().", self.label(),
            ), Init, Missing));
        } else {
            debug!("HELLO");
            match tokio::runtime::Runtime::new() {
                Err(e) => error!(err!(e, errmsg!(
                    "Failed to start Tokio runtime.",
                ), Init)),
                Ok(rt) => rt.block_on(async {
                    self.now_listening();
                    loop {
                        if self.async_listen().await.must_end() { break; }
                    }
                }),
            }
        }
    }
}
impl<
    const BIDL: usize,
    const C: usize,
    const MIDL: usize,
    const SIDL: usize,
    const UIDL: usize,
    BID:    NumIdDat<BIDL> + 'static,
    MID:    NumIdDat<MIDL> + 'static,
    SID:    NumIdDat<SIDL> + 'static,
    UID:    NumIdDat<UIDL> + 'static,
	WENC:   Encrypter + 'static,
	WCS:    Checksummer + 'static,
	POWH:   Hasher + 'static,
	SGN:    Signer + 'static,
	HS:     Encrypter + 'static,
>
    ServerBot<BIDL, C, MIDL, SIDL, UIDL, BID, MID, SID, UID, WENC, WCS, POWH, SGN, HS>
{
    pub fn start(mut self, sentinel: Sentinel) -> Outcome<Handle<()>> {
        let id_string = self.id().to_string();
        let builder = thread::Builder::new()
            .name(id_string.clone())
            .stack_size(constant::STACK_SIZE);
        Ok(Handle::new(
            id_string,
            res!(builder.spawn(move || { self.go(); })),
            sentinel,
        ))
    }
    pub async fn async_listen(&mut self) -> LoopBreak {
        match self.chan_in().recv_timeout(constant::SERVER_INT_CHANNEL_CHECK_INTERVAL) {
            Recv::Empty => (),
            Recv::Result(Err(e)) => self.err_cannot_receive(e, errmsg!(
                "Waiting for message on internal channel",
            )),
            Recv::Result(Ok(ServerMsg::Finish)) => {
                trace!("Finish message received, {:?} finishing now.", self.id());
                return LoopBreak(true);
            },
            Recv::Result(Ok(ServerMsg::Ready)) => {
                info!("{:?} ready to receive messages now.", self.id());
            },
        }
        let mut buf = [0u8; constant::UDP_BUFFER_SIZE]; 
        match self.sock.recv_from(&mut buf) {
            Err(e) => {
                match e.kind() {
                    io::ErrorKind::WouldBlock | io::ErrorKind::InvalidInput => (),
                    _ => self.err_cannot_receive(Error::from(e),
                        errmsg!("Waiting for message on external UDP socket")),
                }
            },
            Ok((n, src_addr)) => {
                let rxenv = self.rxenv.clone();
                let handle = task::spawn(rxenv.process::<MIDL, UIDL, MID, UID>(
                    buf,
                    n,
                    src_addr,
                    self.protocol.schms.syntax.clone(),
                ));
                match handle.await {
                    Ok(result) => self.result(&result),
                    Err(e) => self.error(
                        err!(e, errmsg!("While waiting for request processor to finish"))),
                }
            },
        }
        if self.ma_gc_last.elapsed() > self.ma_gc_int {
            let result = self
                .rxenv.massembler
                .message_assembly_garbage_collection(&self.rxenv.ma_params);
            self.result(&result);
            self.ma_gc_last = Instant::now();
        }
        LoopBreak(false)
    }
}
File: schemes.rs
use crate::msg::syntax;
use fe2o3_core::{
    prelude::*,
    alt::{
        Alt,
        DefAlt,
    },
};
use fe2o3_crypto::{
    enc::EncryptionScheme,
    sign::SignatureScheme,
};
use fe2o3_iop_crypto::{
    enc::{
        Encrypter,
        EncrypterDefAlt,
    },
    sign::{
        Signer,
        SignerDefAlt,
    },
};
use fe2o3_jdat::{
    chunk::{
        ChunkConfig,
    },
};
use fe2o3_hash::{
    csum::{
        ChecksummerDefAlt,
        ChecksumScheme,
    },
    hash::{
        HasherDefAlt,
        HashScheme,
    },
};
use fe2o3_iop_hash::{
    api::Hasher,
    csum::Checksummer,
};
use fe2o3_syntax::core::SyntaxRef;
use std::sync::Arc;
#[derive(Clone, Debug)]
pub struct WireSchemesInput<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>{
    pub enc:    Alt<WENC>,
    pub csum:   Alt<WCS>,
    pub powh:   Alt<POWH>,
    pub sign:   Alt<SGN>,
    pub hsenc:  Alt<HS>,
    pub chnk:   Option<ChunkConfig>,
    pub syntax: SyntaxRef,
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>
    Default for WireSchemesInput<WENC, WCS, POWH, SGN, HS>
{
    fn default() -> Self {
        Self {
            enc:    Alt::Unspecified,
            csum:   Alt::Unspecified,
            powh:   Alt::Unspecified,
            sign:   Alt::Unspecified,
            hsenc:  Alt::Unspecified,
            chnk:   None,
            syntax: SyntaxRef(Arc::new(syntax::empty())),
        }
    }
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>
    WireSchemesInput<WENC, WCS, POWH, SGN, HS>
{
    pub fn ref_encrypter(&self)             -> &Alt<WENC>           { &self.enc }
    pub fn ref_checksummer(&self)           -> &Alt<WCS>            { &self.csum }
    pub fn ref_pow_hasher(&self)            -> &Alt<POWH>           { &self.powh }
    pub fn ref_signer(&self)                -> &Alt<SGN>            { &self.sign }
    pub fn ref_handshake_encrypter(&self)   -> &Alt<HS>             { &self.hsenc }
    pub fn ref_chunk_config(&self)          -> &Option<ChunkConfig> { &self.chnk }
    pub fn ref_syntax(&self)                -> SyntaxRef            { self.syntax.clone() }
    pub fn own_encrypter(&mut self)     -> Alt<WENC>    { std::mem::replace(&mut self.enc, Alt::Unspecified) }
    pub fn own_checksummer(&mut self)   -> Alt<WCS>     { std::mem::replace(&mut self.csum, Alt::Unspecified) }
    pub fn own_pow_hasher(&mut self)    -> Alt<POWH>    { std::mem::replace(&mut self.powh, Alt::Unspecified) }
    pub fn own_signer(&mut self)        -> Alt<SGN>     { std::mem::replace(&mut self.sign, Alt::Unspecified) }
    pub fn own_handshake_encrypter(&mut self) -> Alt<HS> { std::mem::replace(&mut self.hsenc, Alt::Unspecified) }
    pub fn own_chunk_config(&mut self)  -> Option<ChunkConfig>  { std::mem::replace(&mut self.chnk, None) }
    pub fn clone_encrypter(&self)           -> Alt<WENC>                { self.enc.clone() }
    pub fn clone_checksummer(&self)         -> Alt<WCS>                 { self.csum.clone() }
    pub fn clone_pow_hasher(&self)          -> Alt<POWH>                { self.powh.clone() }
    pub fn clone_signer(&self)              -> Alt<SGN>                 { self.sign.clone() }
    pub fn clone_handshake_encrypter(&self) -> Alt<HS>                  { self.hsenc.clone() }
    pub fn clone_chunk_config(&self)        -> Option<ChunkConfig>      { self.chnk.clone() }
    pub fn set_signer(mut self, signer: Option<SGN>) -> Self {
        self.sign = Alt::Specific(signer);
        self
    }
    pub fn set_syntax(mut self, syntax: SyntaxRef) -> Self {
        self.syntax = syntax;
        self
    }
}
#[derive(Clone, Debug)]
pub struct WireSchemes<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>{
    pub enc:    EncrypterDefAlt<EncryptionScheme, WENC>,
    pub csum:   ChecksummerDefAlt<ChecksumScheme, WCS>,
    pub powh:   HasherDefAlt<HashScheme, POWH>,
    pub sign:   SignerDefAlt<SignatureScheme, SGN>,
    pub hsenc:  EncrypterDefAlt<EncryptionScheme, HS>,
    pub chnk:   ChunkConfig,
    pub syntax: SyntaxRef,
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>
    Default for WireSchemes<WENC, WCS, POWH, SGN, HS>
{
    fn default() -> Self {
        Self {
            enc:    EncrypterDefAlt(DefAlt::None),
            csum:   ChecksummerDefAlt(DefAlt::None),
            powh:   HasherDefAlt(DefAlt::None),
            sign:   SignerDefAlt(DefAlt::None),
            hsenc:  EncrypterDefAlt(DefAlt::None),
            chnk:   ChunkConfig::default(),
            syntax: SyntaxRef(Arc::new(syntax::empty())),
        }
    }
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>
    From<WireSchemesInput<WENC, WCS, POWH, SGN, HS>> for WireSchemes<WENC, WCS, POWH, SGN, HS>
{
    fn from(input: WireSchemesInput<WENC, WCS, POWH, SGN, HS>) -> Self {
        Self {
            enc:    EncrypterDefAlt::from(input.enc),
            csum:   ChecksummerDefAlt::from(input.csum),
            powh:   HasherDefAlt::from(input.powh),
            sign:   SignerDefAlt::from(input.sign),
            hsenc:  EncrypterDefAlt::from(input.hsenc),
            chnk:   match input.chnk {
                Some(cfg) => cfg,
                None => ChunkConfig::default(),
            },
            syntax: input.syntax,
        }
    }
}
impl<
	WENC:   Encrypter,
	WCS:    Checksummer,
    POWH:   Hasher,
    SGN:    Signer,
    HS:     Encrypter,
>
    WireSchemes<WENC, WCS, POWH, SGN, HS>
{
    pub fn ref_encrypter(&self)             -> &EncrypterDefAlt<EncryptionScheme, WENC> { &self.enc }
    pub fn ref_checksummer(&self)           -> &ChecksummerDefAlt<ChecksumScheme, WCS>  { &self.csum }
    pub fn ref_pow_hasher(&self)            -> &HasherDefAlt<HashScheme, POWH>          { &self.powh }
    pub fn ref_signer(&self)                -> &SignerDefAlt<SignatureScheme, SGN>      { &self.sign }
    pub fn ref_handshake_encrypter(&self)   -> &EncrypterDefAlt<EncryptionScheme, HS>   { &self.hsenc }
    pub fn ref_chunk_config(&self)          -> &ChunkConfig                             { &self.chnk }
    pub fn ref_syntax(&self)                -> SyntaxRef                                { self.syntax.clone() }
    pub fn clone_encrypter(&self)           -> EncrypterDefAlt<EncryptionScheme, WENC>  { self.enc.clone() }
    pub fn clone_checksummer(&self)         -> ChecksummerDefAlt<ChecksumScheme, WCS>   { self.csum.clone() }
    pub fn clone_pow_hasher(&self)          -> HasherDefAlt<HashScheme, POWH>           { self.powh.clone() }
    pub fn clone_signer(&self)              -> SignerDefAlt<SignatureScheme, SGN>       { self.sign.clone() }
    pub fn clone_handshake_encrypter(&self) -> EncrypterDefAlt<EncryptionScheme, HS>    { self.hsenc.clone() }
    pub fn clone_chunk_config(&self)        -> ChunkConfig                              { self.chnk.clone() }
}
File: packet.rs
use crate::{
    constant,
    msg::external::{
        HandshakeType,
        MsgType,
    },
};
use fe2o3_core::{
    prelude::*,
    byte::{
        FromBytes,
        ToBytes,
    },
};
use fe2o3_iop_crypto::sign::Signer;
use fe2o3_jdat::{
    id::NumIdDat,
    version::SemVer,
};
use fe2o3_hash::{
    pow::{
        PowCreateParams,
        PowSearchResult,
        PowVars,
        Pristine,
        ProofOfWork,
    },
};
use fe2o3_iop_hash::api::Hasher;
use fe2o3_net::id::{
    Mid,
    Uid,
};
use fe2o3_namex::id::LocalId;
use std::{
    convert::TryFrom,
    ops::Range,
    sync::Arc,
};
pub type PacketCount = u32;
pub const PACKET_COUNT_BYTE_LEN: usize = 4;
#[derive(Clone, Debug, Default)]
pub struct PacketChunkState {
    pub index:      PacketCount,
    pub num_chunks: PacketCount,
    pub chunk_size: u16,
    pub pad_last:   bool,
}
impl ToBytes for PacketChunkState {
    fn to_bytes(&self, mut buf: Vec<u8>) -> Outcome<Vec<u8>> {
        buf.extend_from_slice(&self.index.to_be_bytes());
        buf.extend_from_slice(&self.num_chunks.to_be_bytes());
        buf.extend_from_slice(&self.chunk_size.to_be_bytes());
        buf.push(if self.pad_last { 1 } else { 0 });
        Ok(buf)
    }
}
impl FromBytes for PacketChunkState {
    fn from_bytes(buf: &[u8]) -> Outcome<(Self, usize)> {
        let mut result = Self::default();
        if buf.len() < Self::BYTE_LEN {
            return Err(err!(errmsg!(
                "Not enough bytes to decode, require at least {}, found only {}.",
                Self::BYTE_LEN, buf.len(),
            ), Bytes, Input,
            Decode, Missing));
        }
        let mut n: usize = 0;
        result.index = PacketCount::from_be_bytes(res!(
            <[u8; PACKET_COUNT_BYTE_LEN]>::try_from(
                &buf[n..n + PACKET_COUNT_BYTE_LEN]
        ), Decode, Bytes));
        n += PACKET_COUNT_BYTE_LEN;
        result.num_chunks = PacketCount::from_be_bytes(res!(
            <[u8; PACKET_COUNT_BYTE_LEN]>::try_from(
                &buf[n..n + PACKET_COUNT_BYTE_LEN]
        ), Decode, Bytes));
        n += PACKET_COUNT_BYTE_LEN;
        result.chunk_size = u16::from_be_bytes(res!(
            <[u8; 2]>::try_from(
                &buf[n..n + 2]
        ), Decode, Bytes));
        n += 2;
        result.pad_last = match u8::from_be_bytes(res!(
            <[u8; 1]>::try_from(
                &buf[n..n + 1]
        ), Decode, Bytes)) {
            0 => false,
            _ => true,
        };
        n += 1;
        Ok((result, n))
    }
}
impl PacketChunkState {
    pub const BYTE_LEN: usize = 2 * PACKET_COUNT_BYTE_LEN + 2 + 1;
}
#[derive(Clone, Debug)]
pub struct PacketMeta<
    const MIDL: usize,
    const UIDL: usize,
    MID: NumIdDat<MIDL>,
    UID: NumIdDat<UIDL>,
> {
    pub typ:    MsgType,
    pub ver:    SemVer,
    pub mid:    Mid<MIDL, MID>,
    pub uid:    Uid<UIDL, UID>,
    pub chnk:   PacketChunkState,
}
impl<
    const MIDL: usize,
    const UIDL: usize,
    MID: NumIdDat<MIDL>,
    UID: NumIdDat<UIDL>,
>
    Default for PacketMeta<MIDL, UIDL, MID, UID>
{
    fn default() -> Self {
        Self {
            typ:    0,
            ver:    SemVer::default(),
            mid:    Mid::<MIDL, MID>::default(),
            uid:    Uid::<UIDL, UID>::default(),
            chnk:   PacketChunkState::default(),
        }
    }
}
impl<
    const MIDL: usize,
    const UIDL: usize,
    MID: NumIdDat<MIDL>,
    UID: NumIdDat<UIDL>,
>
    ToBytes for PacketMeta<MIDL, UIDL, MID, UID>
{
    fn to_bytes(&self, mut buf: Vec<u8>) -> Outcome<Vec<u8>> {
        buf.extend_from_slice(&self.typ.to_be_bytes());
        buf = res!(self.ver.to_bytes(buf));
        buf = res!(self.mid.to_bytes(buf));
        buf = res!(self.uid.to_bytes(buf));
        buf = res!(self.chnk.to_bytes(buf));
        Ok(buf)
    }
}
impl<
    const MIDL: usize,
    const UIDL: usize,
    MID: NumIdDat<MIDL>,
    UID: NumIdDat<UIDL>,
>
    FromBytes for PacketMeta<MIDL, UIDL, MID, UID>
{
    fn from_bytes(buf: &[u8]) -> Outcome<(Self, usize)> {
        let mut result = Self::default();
        if buf.len() < Self::BYTE_LEN {
            return Err(err!(errmsg!(
                "Not enough bytes to decode, require at least {}, found only {}.",
                Self::BYTE_LEN, buf.len(),
            ), Bytes, Input,
            Decode, Missing));
        }
        let mut n = constant::MSG_TYPE_BYTE_LEN;
        result.typ = MsgType::from_be_bytes(res!(
            <[u8; constant::MSG_TYPE_BYTE_LEN]>::try_from(&buf[0..n]),
                Decode, Bytes)
        );
        let (ver, n2) = res!(SemVer::from_bytes(&buf[n..]));
        result.ver = ver;
        n += n2;
        let (mid, n_mid) = res!(Mid::<MIDL, MID>::from_bytes(&buf[n..]));
        result.mid = mid;
        n += n_mid;
        let (uid, n_uid) = res!(Uid::<UIDL, UID>::from_bytes(&buf[n..]));
        result.uid = uid;
        n += n_uid;
        let (chnk, n0) = res!(PacketChunkState::from_bytes(&buf[n..]));
        result.chnk = chnk;
        n += n0;
        Ok((result, n))
    }
}
impl<
    const MIDL: usize,
    const UIDL: usize,
    MID: NumIdDat<MIDL>,
    UID: NumIdDat<UIDL>,
>
    PacketMeta<MIDL, UIDL, MID, UID>
{
    pub const BYTE_LEN: usize =
        constant::MSG_TYPE_BYTE_LEN +
        SemVer::BYTE_LEN +
        MIDL +
        UIDL +
        PacketChunkState::BYTE_LEN;
}
#[repr(u8)]
pub enum PacketValidatorId {
    Pow = 1,
    BareSignature = 2,
    SignatureWithKey = 3,
}
impl TryFrom<u8> for PacketValidatorId {
    type Error = Error<ErrTag>;
    fn try_from(n: u8) -> std::result::Result<Self, Self::Error> {
        match n {
            1 => Ok(Self::Pow),
            2 => Ok(Self::BareSignature),
            3 => Ok(Self::SignatureWithKey),
            _ => Err(err!(errmsg!(
                "Number {} not recognised as a PacketValidatorId.", n,
            ), Input, Invalid)),
        }
    }
}
#[derive(Default)]
pub struct PacketValidationArtefactRelativeIndices {
    pub pow: Option<Range<usize>>,
    pub sig: Option<(Range<usize>, Option<(Range<usize>, Range<usize>)>)>,
}
impl FromBytes for PacketValidationArtefactRelativeIndices {
    fn from_bytes(buf: &[u8]) -> Outcome<(Self, usize)> {
        let mut result = Self::default();
        let mut n: usize = 0;
        match PacketValidatorId::try_from(buf[n] as u8) {
            Ok(PacketValidatorId::Pow) => {
                n += 1;
                let (len, ns) = res!(Self::read_size(&buf, n));
                n += ns;
                result.pow = Some(n..n + len);
                n += len;
            },
            _ => result.pow = None,
        }
        match PacketValidatorId::try_from(buf[n] as u8) {
            Ok(pvid) => {
                match pvid {
                    PacketValidatorId::BareSignature | PacketValidatorId::SignatureWithKey => {
                        n += 1;
                        let (len, ns) = res!(Self::read_size(&buf, n));
                        n += ns;
                        let sigval_rng = n..n + len;
                        let withkey_ranges = if let PacketValidatorId::SignatureWithKey = pvid {
                            let (pk_len, ns) = res!(Self::read_size(&buf, n));
                            n += ns;
                            let pk_rng = n..n + pk_len;
                            n += pk_len;
                            let (sig_len, ns) = res!(Self::read_size(&buf, n));
                            n += ns;
                            let sig_rng = n..n + sig_len;
                            n += sig_len;
                            if sigval_rng.end != sig_rng.end {
                                return Err(err!(errmsg!(
                                    "The end point of the overall relative signature artefact range, \
                                    {:?}, should match the end point of the relative range of the actual \
                                    signature, {:?}, when the public key (range {:?}) is included.",
                                    sigval_rng, sig_rng, pk_rng,
                                ), Bug, Index, Mismatch));
                            }
                            Some((pk_rng, sig_rng))
                        } else {
                            n += len;
                            None
                        };
                        result.sig = Some((sigval_rng, withkey_ranges));
                    },
                    _ => result.sig = None,
                }
            },
            _ => result.sig = None,
        }
        Ok((result, n))
    }
}
impl PacketValidationArtefactRelativeIndices {
    pub const BYTE_PREFIX_LEN: usize = 1 + 2;
    fn read_size(buf: &[u8], n: usize) -> Outcome<(usize, usize)> {
        Ok((
            u16::from_be_bytes(res!(<[u8; 2]>::try_from(&buf[n..n+2]),
                Decode, Bytes)) as usize, 
            2,
        ))
    }
}
#[derive(Clone, Debug, Default)]
pub struct PacketValidator<
    H: Hasher + Send + 'static,
    S: Signer,
> {
    pub pow: Option<ProofOfWork<H>>,
    pub sig: Option<S>,
}
impl<
    H: Hasher + Send + 'static,
    S: Signer,
>
    PacketValidator<H, S>
{
    pub fn to_bytes<
        const N: usize,
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
    >(
        &self,
        mut buf:    Vec<u8>,
        powparams:  &PowCreateParams<P0, P1, PRIS>,
        inc_sigpk:  bool,
    )
        -> Outcome<Vec<u8>>
    {
        if let Some(power) = &self.pow {
            match power.create::<N, P0, P1, PRIS>(powparams) {
                Ok(PowSearchResult{
                    found,
                    mut artefact,
                    elapsed,
                    err,
                    ..
                }) => {
                    if let Some(e) = err {
                        return Err(e);
                    }
                    if !found {
                        return Err(err!(errmsg!(
                            "Proof of work validator: search timed out after {:?}.",
                            elapsed,
                        ), Timeout, Missing));
                    }
                    trace!("POW tx:");
                    res!(self.trace(
                        Some(&powparams.pvars),
                        &artefact,
                    ));
                    buf.extend_from_slice(&(PacketValidatorId::Pow as u8).to_be_bytes());
                    buf.extend_from_slice(&(artefact.len() as u16).to_be_bytes());
                    buf.append(&mut artefact);
                },
                Err(e) => return Err(e),
            }
        }
        if let Some(signer) = &self.sig {
            match inc_sigpk {
                true => {
                    let mut sig = res!(signer.sign(&buf));
                    let pk = match res!(signer.get_public_key()) {
                        Some(k) => k,
                        None => return Err(err!(errmsg!(
                            "Signature validator: public key not available.",
                        ), Bug, Configuration, Missing)),
                    };
                    let mut artefact = Vec::new();
                    artefact.extend_from_slice(&(pk.len() as u16).to_be_bytes());
                    artefact.extend_from_slice(&pk[..]);
                    artefact.extend_from_slice(&(sig.len() as u16).to_be_bytes());
                    artefact.append(&mut sig);
                    buf.extend_from_slice(&(PacketValidatorId::SignatureWithKey as u8).to_be_bytes());
                    buf.extend_from_slice(&(artefact.len() as u16).to_be_bytes());
                    buf.append(&mut artefact);
                },
                false => {
                    let mut artefact = res!(signer.sign(&buf));
                    buf.extend_from_slice(&(PacketValidatorId::BareSignature as u8).to_be_bytes());
                    buf.extend_from_slice(&(artefact.len() as u16).to_be_bytes());
                    buf.append(&mut artefact);
                },
            }
        }
        Ok(buf)
    }
    pub fn validate<
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
    >(
        self,
        buf:            &[u8],
        n0:             usize,
        afact_rel_ind:  PacketValidationArtefactRelativeIndices,
        powvars:        Option<PowVars<P0, P1, PRIS>>,
        msg_typ:        MsgType,
    )
        -> Outcome<PacketValidationResult>
    {
        let pow = match self.pow {
            Some(power) => {
                let powvars = res!(powvars.ok_or(err!(errmsg!(
                    "Proof of work validation missing requirements.",
                ), Bug, Configuration, Missing)));
                match afact_rel_ind.pow {
                    Some(range) => {
                        Some(res!(power.validate(
                            &powvars,
                            &buf[n0 + range.start..n0 + range.end],
                        )))
                    }
                    None => return Err(err!(errmsg!(
                        "Proof of work validation missing artefact.",
                    ), Bug, Configuration, Missing)),
                }
            },
            None => None,
        };
        let sig = match self.sig {
            Some(mut signer) => match afact_rel_ind.sig {
                Some((range, None)) => {
                    let len = range.len() + PacketValidationArtefactRelativeIndices::BYTE_PREFIX_LEN;
                    Some((
                        res!(signer.verify(
                            &buf[..buf.len() - len],
                            &buf[n0 + range.start..n0 + range.end],
                        )),
                        None,
                    ))
                },
                Some((range, Some((pk_rng, sig_rng)))) => {
                    if HandshakeType::from(msg_typ) != HandshakeType::Req1 {
                        return Ok(PacketValidationResult {
                            pow,
                            sig: None,
                        });
                    }
                    let len = range.len() + PacketValidationArtefactRelativeIndices::BYTE_PREFIX_LEN;
                    let pk = &buf[n0 + pk_rng.start..n0 + pk_rng.end];
                    signer = res!(signer.set_public_key(Some(&pk[..])));
                    Some((
                        res!(signer.verify(
                            &buf[..buf.len() - len],
                            &buf[n0 + sig_rng.start..n0 + sig_rng.end],
                        )),
                        Some((signer.local_id(), pk)),
                    ))
                },
                None => return Err(err!(errmsg!(
                    "Validator requires a signature but no artefact has been included.",
                ), Bug, Configuration, Missing)),
            },
            None => None,
        };
        Ok(PacketValidationResult {
            pow,
            sig,
        })
    }
    pub fn trace<
        const P0: usize,
        const P1: usize,
        PRIS: Pristine<P0, P1>,
    >(
        &self,
        powvars:    Option<&PowVars<P0, P1, PRIS>>,
        artefact:   &[u8],
    )
        -> Outcome<()>
    {
        match &self.pow {
            Some(power) => {
                match powvars {
                    Some(powvars) => {
                        let hlen = res!(power.hasher.len());
                        let alen = artefact.len();
                        let nlen = alen - hlen - (P1-P0);
                        let h_start = alen - hlen;
                        let n_start = h_start - nlen;
                        let pristine = res!(powvars.pristine.to_bytes());
                        trace!("\nPristine    [{:>4}]: {:02x?}\
                            \n  Prefix    [{:>4}]: {:02x?}\
                            \nArtefact    [{:>4}]: {:02x?}\
                            \n  Nonce     [{:>4}]: {:02x?}\
                            \n  Hash      [{:>4}]: {:02x?}",
                            P1, pristine,
                            P0, &pristine[..P0],
                            alen, artefact,
                            nlen, &artefact[n_start..h_start],
                            hlen, &artefact[h_start..],
                        );
                    },
                    None => return Err(err!(errmsg!(
                        "Proof of work validation missing requirements.",
                    ), Bug, Configuration, Missing)),
                }
            },
            None => trace!("No proof of work hasher provided."),
        }
        Ok(())
    }
}
#[derive(Debug)]
pub struct PacketValidationResult<'a> {
    pow: Option<bool>,
    sig: Option<(bool, Option<(LocalId, &'a[u8])>)>,
}
impl<'a> PacketValidationResult<'a> {
    pub fn is_valid(self) -> Option<(bool, Option<(LocalId, &'a[u8])>)> {
        match self.pow {
            Some(pb) => match self.sig {
                Some((sb, pk_opt)) => Some((pb && sb, pk_opt)),
                None => Some((pb, None)),
            },
            None => match self.sig {
                Some((sb, pk_opt)) => Some((sb, pk_opt)),
                None => None,
            },
        }
    }
    pub fn pow_invalid(&self) -> bool {
        match self.pow {
            Some(b) => !b,
            None => false,
        }
    }
    pub fn sig_invalid(&self) -> bool {
        match self.sig {
            Some((b, _)) => !b,
            None => false,
        }
    }
    pub fn pow_state(&self) -> &'static str {
        match self.pow {
            Some(true) => "PASS",
            Some(false) => "FAIL",
            None => "NONE",
        }
    }
    pub fn sig_state(&self) -> &'static str {
        match self.sig {
            Some((true, _)) => "PASS",
            Some((false, _)) => "FAIL",
            None => "NONE",
        }
    }
}
